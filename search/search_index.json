{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    about.md  # Other markdown pages, images and other files.\n</code></pre>"},{"location":"about/","title":"About This Project","text":"<p>Welcome to My Site! This project is dedicated to documenting the various aspects of my work. Below is some useful information about the purpose of this project.</p>"},{"location":"about/#project-overview","title":"Project Overview","text":"<p>This site is designed to provide clear and organized documentation for the project hosted on GitHub. It covers everything from installation instructions to advanced usage and examples.</p> <p>The primary goals of this project are: - To facilitate better understanding of how the code works. - To offer tutorials and examples for getting started. - To provide ongoing updates and improvements.</p>"},{"location":"about/#motivation","title":"Motivation","text":"<p>The project was created with the intention of making it easier for developers and collaborators to contribute and understand the codebase. My goal is to ensure that this repository remains useful and maintainable over time.</p>"},{"location":"about/#technology-stack","title":"Technology Stack","text":"<ul> <li>MkDocs: A static site generator that's simple and easy to use.</li> <li>Material for MkDocs: A modern and responsive theme for MkDocs.</li> <li>Markdown: Used for writing all the documentation.</li> </ul>"},{"location":"about/#how-to-contribute","title":"How to Contribute","text":"<p>If you would like to contribute to the project, feel free to submit pull requests or open issues on the GitHub repository.</p>"},{"location":"about/#contact","title":"Contact","text":"<p>If you have any questions, feel free to reach out via the GitHub repository or through email@example.com.</p>"},{"location":"tema-2/practica2-1/","title":"Autor: Manuel G\u00f3mez Ruiz","text":""},{"location":"tema-2/practica2-1/#asignatura-despliegue-de-aplicaciones-web","title":"Asignatura: Despliegue de Aplicaciones Web","text":""},{"location":"tema-2/practica2-1/#fecha-10102024","title":"Fecha: 10/10/2024","text":""},{"location":"tema-2/practica2-1/#curso-2o-de-desarrollo-de-aplicaciones-web","title":"Curso: 2\u00ba de Desarrollo de Aplicaciones Web","text":""},{"location":"tema-2/practica2-1/#practica-21-instalacion-y-configuracion-de-un-servidor-web-nginx","title":"Pr\u00e1ctica 2.1 - Instalaci\u00f3n y configuraci\u00f3n de un servidor web Nginx","text":""},{"location":"tema-2/practica2-1/#el-objetivo-de-la-practica-es-instalar-y-configurar-un-servidor-web-en-un-so-debian-de-tal-forma-que-permita-conexiones-por-https-y-ftp","title":"El objetivo de la pr\u00e1ctica es instalar y configurar un servidor web en un SO Debian, de tal forma que permita conexiones por HTTPS y FTP.","text":""},{"location":"tema-2/practica2-1/#instalacion-servidor-web-nginx","title":"Instalaci\u00f3n servidor web Nginx","text":"<p>Lo primera ser\u00eda actualizar los repositorios e instalar el paquetes correspondiente que contienen el servidor Nginx, para ello usaremos el comando sudo apt update &amp;&amp; sudo apt install nginx</p> <p>Esto descargar\u00e1 e instalar\u00e1 Nginx desde los repositorios oficiales de tu distribuci\u00f3n.</p> <p></p> <p>Una vez instalado, es crucial comprobar que Nginx se haya instalado correctamente y que el servicio est\u00e9 activo, para ello utilizaremos el comando sudo systemctl status nginx para verificar el estado.</p> <p></p> <p>Ahora, crearemos las carpetas necesarias para el sitio web que alojar\u00e1 Nginx. Para ello utilizaremos el comando mkdir -p para crear m\u00faltiples carpetas de manera recursiva, y en esa carpeta almacenar los archivos del sitio web.</p> <p></p> <p>Ahora clonamos el repositorio de GitHub que contendr\u00e1 una plantilla para nuestro servidor, para ello utiliza el comando git clone junto a la url del repositorio de CloudAcademy https://github.com/cloudacademy/sample-web-app.git, debes clonarlo en /var/www/tu_sitio_web/html</p> <p></p> <p>Necesitamos asegurarnos de que el servidor Nginx tenga los permisos adecuados para acceder y servir los archivos, utiliza los comandos chown y otorga los permisos correctos al usuario y grupo www-data (usuario predeterminado de Nginx)</p> <p></p> <p>Verificamos el funcionamiento del servidor, para ello introduce el comando ip a y copia tu IP, despu\u00e9s introduce en el navegador http://tu_ip</p> <p></p>"},{"location":"tema-2/practica2-1/#configuracion-de-servidor-web-nginx","title":"Configuraci\u00f3n de servidor web NGINX","text":"<p>Editamos el archivo de configuraci\u00f3n del sitio web para personalizar la configuraci\u00f3n de Nginx, utiliza el comando nano /etc/nginx/sites-available/tu-sitio-web</p> <p></p> <p>Hacemos el enlace simb\u00f3lico con el comando ln -s para hacer que Nginx lo reconozca como un sitio activo, lo agregue en la carpeta sites-enabled y est\u00e9 disponible en el servidor.</p> <p></p> <p>En nuestra m\u00e1quina anfitriona, entra en la ruta C:\\Windows\\System32\\drivers\\etc\\hosts con permisos de administrador y a\u00f1ade en la \u00faltima l\u00ednea la IP de tu Debian y el nombre de tu p\u00e1gina web, esto har\u00e1 que podamos acceder al sitio web de nuestra m\u00e1quina virtual desde nuestro anfitri\u00f3n.</p> <p></p> <p>Comprobamos que las peticiones se est\u00e9n registrando en los archivos de registro (logs) de Nginx.</p> <p></p>"},{"location":"tema-2/practica2-1/#ftp","title":"FTP","text":"<p>Para configurar un servidor FTP en Debian y as\u00ed permitir la transferencia de archivos, debemos de instalar vsftpd, que es un servidor FPT ligero y seguro.</p> <p></p> <p>Creamos carpeta en el Home llamada FTP, que ser\u00e1 a la que se acceder\u00e1n los clientes a trav\u00e9s del puerto 21, para la subida o descarga de archivos.</p> <p></p> <p>Modificaci\u00f3n del fichero /etc/vsftpd.conf, para permitir el acceso a usuarios locales, a\u00f1adir SSL y certificado.</p> <p></p> <p>Reiniciamos el servicio vsftpd para que los cambios hagan efecto.</p> <p></p> <p>Instalamos FileZilla en nuestro anfitri\u00f3n y realizamos una conexi\u00f3n FTP al servidor a trav\u00e9s del puerto 21, para ello necesitamos la IP del servidor, su nombre de usuario y contrase\u00f1a.</p> <p></p> <p>Nos dar\u00e1 informaci\u00f3n sobre el certificado de seguridad.</p> <p></p> <p>Acceso realizado con \u00e9xito.</p> <p></p> <p>Ahora vamos a intentar realizar una conexi\u00f3n a trav\u00e9s del puerto 22.</p> <p></p> <p>Y pasamos un fichero .ZIP a trav\u00e9s de FTP.</p> <p></p> <p>Comprobamos que ha llegado correctamente al servidor.</p> <p></p>"},{"location":"tema-2/practica2-1/#https","title":"HTTPS","text":"<p>Para habilitar la seguridad en tu sitio web, es importante configurar HTTPS, que garantiza que la informaci\u00f3n entre el cliente y el servidor est\u00e9 cifrada. Para ello, necesitaremos crear un certificado SSL.</p> <p>Instalamos openssl, herramienta fundamental para generar certificados SSL.</p> <p></p> <p>Generamos el certificado utilizando OpenSSL.</p> <p></p> <p>Configuramos Nginx para que utilice HTTPS. Para ello, edita el archivo de configuraci\u00f3n usando sudo nano /etc/nginx/sites-available/tu-sitio-web, y a\u00f1ade las rutas del certificado SSL, el nombre del servidor, el directorio principal y asegurate que Nginx escuche en el puerto 443.</p> <p></p> <p>Comprobamos con el comando nginx -t que la sintaxis y la configuraci\u00f3n son v\u00e1lidas.</p> <p></p> <p>Modificamos de nuevo nuestro fichero host, con las direcciones a\u00f1adidas anteriormente a server_name.</p> <p></p> <p>Probamos a conectarnos a trav\u00e9s de HTTP en nuestra m\u00e1quina anfitriona.</p> <p></p> <p>Nos conectamos a trav\u00e9s de HTTPS.</p> <p></p>"},{"location":"tema-2/practica2-2/","title":"Actividad 2.2 - Autenticaci\u00f3n en Nginx","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 15/10/2024</p> <p>Curso: 2\u00ba de Desarrollo de Aplicaciones Web</p>"},{"location":"tema-2/practica2-2/#practica-22-autenticacion-en-un-servidor-nginx","title":"Pr\u00e1ctica 2.2 - Autenticaci\u00f3n en un servidor Nginx.","text":""},{"location":"tema-2/practica2-2/#objetivo-de-la-practica-aprender-a-configurar-el-acceso-a-paginas-web","title":"Objetivo de la pr\u00e1ctica: Aprender a configurar el acceso a p\u00e1ginas web.","text":"<p>Paquetes necesarios para realizar la pr\u00e1ctica.</p> <p>Utiliza el comando dpkg -l | grep openssl, en caso de que el resultado no muestre el paquete openssl,  instalalo con el comando sudo apt install openssl</p> <p></p> <p>El comando dpkg -l lista todos los paquetes instalados en el sistema con informaci\u00f3n detallada, mientras que  grep openssl busca el nombre del paquete openssl dentro de nuestro sistema.</p>"},{"location":"tema-2/practica2-2/#creacion-de-usuarios-y-contrasenas-para-el-acceso-web","title":"Creaci\u00f3n de usuarios y contrase\u00f1as para el acceso web","text":"<p>A continuaci\u00f3n, vamos a crear los usuarios de nuestra p\u00e1gina web con sus respetivas contrase\u00f1as, las cuales se  guardar\u00e1n encriptada en un fichero llamado .htpasswd</p> <p>Utiliza el comando sudo sh -c \"echo -n 'usuario-web:' &gt;&gt; /etc/nginx/.htpasswd, el cual creara el fichero  .htpasswd y le agregar\u00e1 el nombre del usuario.</p> <p></p> <p>Haz lo mismo con las contrase\u00f1as, para ello usa el comando sudo sh -c \"openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd\",  este comando ser\u00e1 el encargado de guardar las contrase\u00f1as encriptadas, gracias al openssl passwd -apr1.</p> <p></p> <ul> <li>Crea dos usuarios, uno con tu nombre y otro con tu primero apellido.</li> </ul> <p>Debes de realizar el mismo proceso que antes, pero ahora crea un usuario con tu propio nombre, comando sudo sh -c \"echo -n 'tu-nombre:' &gt;&gt; /etc/nginx/.htpasswd para a\u00f1adir al usuario y  sudo sh -c \"openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd\" para la contrase\u00f1a.</p> <p></p> <p>Usuario con mi apellido.</p> <p></p> <ul> <li>Comprueba que el usuario y la contrase\u00f1a aparecen cifrados en el fichero:</li> </ul> <p>Para ello debemos revisar el archivo donde se almacenan las contrase\u00f1a de nuestro servidor, en mi caso voy a utilizar un  comando que visualiza lo que hay dentro del archivo sin necesidad de abrirlo con un editor, comando sudo cat /etc/nginx/.htpasswd</p> <p></p>"},{"location":"tema-2/practica2-2/#configurando-el-servidor-nginx-para-usar-una-autentificacion-basica","title":"Configurando el servidor Nginx para usar una autentificaci\u00f3n b\u00e1sica","text":"<p>A\u00f1adimos la autenticaci\u00f3n en el fichero /etc/nginx/sites-availables/nombre-web, para ello utilizamos la  directiva auth_basic que solicita la autenticaci\u00f3n a los usuarios que intentar acceder a un recurso protegido  y enlazamos el fichero .htpasswd con los usuarios y contrase\u00f1as a la directiva auth_basic_user_file </p> <p></p> <p>Reiniciamos el servidor con el comando sudo systemctl restart nginx para as\u00ed aplicar los cambios del archivo de  configuraci\u00f3n /etc/nginx/sites-available/nombre-web y comprobamos que no haya ning\u00fan error con un sudo systemctl status nginx</p> <p></p>"},{"location":"tema-2/practica2-2/#probando-la-nueva-configuracion","title":"Probando la nueva configuraci\u00f3n","text":"<p>Comprobaci\u00f3n 1: Comprueba desde tu m\u00e1quina f\u00edsica/anfritiona que puedes acceder a https://nombre-sitio-web y que se  solicita la autenticaci\u00f3n.</p> <p>Entra en la p\u00e1gina web e introduce un usuario incorrecto.</p> <p></p> <p>El resultado ser\u00e1 que te volver\u00e1n a pedir las credenciales de acceso.</p> <p></p> <p>Ahora metemos un usuario que est\u00e9 dentro del fichero .htpasswd con su correspondiente contrase\u00f1a correcta.</p> <p></p> <p>Como ves nos deja acceder a la p\u00e1gina web.</p> <p></p> <p>Esta configuraci\u00f3n hace que con un solo acceso correcto, ya no tengas que volver a loguearte m\u00e1s en ese navegador, por lo que no  es demasiado segura.</p> <p>Comprobaci\u00f3n 2: Comprueba que si decides cancelar la autenticaci\u00f3n, se te negar\u00e1 el acceso al sitio con un error.  \u00bfQu\u00e9 error es?</p> <p>Error 401: Authorization required, es un c\u00f3digo de estado HTTP que indica que la solicitud realizada por el cliente no tiene las  credenciales de autenticaci\u00f3n necesarias para acceder al recurso solicitado.</p> <p></p>"},{"location":"tema-2/practica2-2/#tareas","title":"Tareas","text":"<p>Tarea 1</p> <ul> <li> <p>Intenta entrar primero con un usuario err\u00f3neo y luego con otro correcto. Puedes ver todos los sucesos y registros en los  logs access.log y error.log</p> </li> <li> <p>Adjunta una captura de pantalla de los logs donde se vea que intentas entrar primero con un usuario inv\u00e1lido y con otro v\u00e1lido.  Indica d\u00f3nde podemos ver los errores de usuario inv\u00e1lido o no encontrado, as\u00ed como donde podemos ver el n\u00famero de error que os aparec\u00eda antes</p> </li> </ul> <p>Archivo log error.log, para verlo he utilizado el comando sudo cat /var/log/nginx/access.log, y he marcado con rojo los \u00faltimos  errores generados por usuarios incorrectos, aunque ser\u00eda m\u00e1s correcto utilizar sudo tail -n 3 /var/log/access.log, esto proporcionar\u00eda  solo los 3 \u00faltimos errores generados en error.log haciendo la salida por pantalla mucho m\u00e1s limpia.</p> <p></p> <p>Archivo log access.log, comando sudo tail -n 5 /var/log/nginx/access.log</p> <p></p> <p>Tarea 2</p> <ul> <li>Borra las dos l\u00edneas que hacen referencia a la autenticaci\u00f3n b\u00e1sica en el location del directorio ra\u00edz. Tras ello, a\u00f1ade un nuevo location  debajo con la autenticaci\u00f3n b\u00e1sica para el archivo/secci\u00f3n contact.html \u00fanicamente.</li> </ul> <p>Lo primero de todo es crear el archivo contact.html, para ello voy a copiar el index.html para meterlo dentro del archivo  contact.html y voy a cambiar un poco el fichero, comandos: sudo cp ./index.html contact.html y sudo nano contact.html.</p> <p>(A pesar de que en la imagen se ve como creo el archivo contacto.html en vez de contact.html, posteriormente modifico su nombre)</p> <p></p> <p>Modificamos el archivo de configuraci\u00f3n, quitando la autenticaci\u00f3n en la ra\u00edz del servidor, y a\u00f1adiendosela a contact.html.</p> <p></p> <p>Despu\u00e9s de esto, reiniciamos el servidor Nginx para aplicar los cambios, sudo systemctl restart nginx.</p> <p>Probamos los cambios en nuestro equipo anfitri\u00f3n, accediendo a contact.html, como se puede apreciar, debido a los cambios en el  archivo de configuraci\u00f3n, al entrar nos pide la autenticaci\u00f3n.</p> <p></p>"},{"location":"tema-2/practica2-2/#combinacion-de-la-autenticacion-basica-con-la-restriccion-de-acceso-por-ip","title":"Combinaci\u00f3n de la autenticaci\u00f3n b\u00e1sica con la restricci\u00f3n de acceso por IP.","text":"<p>La autenticaci\u00f3n b\u00e1sica HTTP puede ser combinada de forma efectiva con la restricci\u00f3n de acceso por direcci\u00f3n IP. Se pueden  implementar dos escenario:</p> <ul> <li> <p>Un usuario debe estar ambas cosas, autenticado y tener una IP v\u00e1lida</p> </li> <li> <p>Un usuario debe o bien estar autenticado, o bien tener una IP v\u00e1lida</p> </li> </ul> <p>Veamos c\u00f3mo lo har\u00edamos:</p> <ol> <li>Como permitir o denegar acceso sobre una IP concreta (directivas allow y deny, respectivamente). Dentro del block server o  archivo de configuraci\u00f3n del dominio web, que recordad est\u00e1 en el directorio sites-available:</li> </ol> <p>He cambiado de red, por eso cambiaron mis IPs, el servidor ahora tiene la IP 192.168.116.128, si te pasa algo parecido solo cambia la  IP del archivo hosts y a\u00f1ade las nuevas IPs al archivo de configuraci\u00f3n del servidor.</p> <p>En este primer caso, voy a permitir el acceso a la p\u00e1gina web al cliente con la IP 192.168.116.121 , el acceso estar\u00e1 rechazado para  todos los dem\u00e1s, tanto en index.html como en contact.html. Si permitiese la puerta de enlace de mi red con la directiva  allow mi-red/24; estar\u00eda permitiendo el acceso a todo dispositivo de mi red local que tuviese configurado en el archivo hosts  el DNS del servidor.</p> <p></p> <p>Haz un restart para guardar los cambios.</p> <ol> <li>Combinar la restricci\u00f3n IP y la autenticaci\u00f3n HTTP con la directiva satisfy.</li> </ol> <p>En este caso, la directiva satisfy nos permite definir si queremos el acceso para todo tipo de usuarios, si debe tener una IP  v\u00e1lida o usuario v\u00e1lido o si ambas cosas deben ser v\u00e1lidas para acceder, podemos combinarlo con las directivas deny y allow  para tener m\u00e1s control.</p> <p>En mi caso, he usado estas directivas para permitir a todos los usuarios de mi subred menos el servidor, acceder a la p\u00e1gina web,  siempre y cuando tengan configurado el DNS en el archivo hosts (se hizo en la pr\u00e1ctica anterior), para ello he a\u00f1adido mi puerta  de enlace como IPs permitidas.</p> <p></p>"},{"location":"tema-2/practica2-2/#tareas-2","title":"Tareas (2)","text":"<p>Tarea 1 - Configura Nginx para que no deje acceder con la IP de la m\u00e1quina anfitriona al directorio ra\u00edz de una de tus dos webs.  Modifica su server block o archivo de configuraci\u00f3n. Comprueba como se deniega el acceso:</p> <p>Accede al archivo de configuraci\u00f3n /etc/nginx/sites-available/sitio-web</p> <p></p> <ul> <li>Muestra la p\u00e1gina de error en el navegador.</li> </ul> <p>Primero entramos a la p\u00e1gina web principal y comprobamos que funciona correctamente.</p> <p></p> <p>Ahora accedemos a contact.html</p> <p>Nos aparecer\u00e1 Error 403 Forbidden, este c\u00f3digo de estado HTTP indica que el servidor ha entendido la solicitud del cliente, pero se  niega a autorizarla, es decir, el cliente est\u00e1 autenticado pero no tiene permisos para acceder.</p> <p></p> <ul> <li>Muestra el mensaje de error de error.log, comando: sudo tail -n 1 /var/log/nginx/error.log</li> </ul> <p></p> <p>Tarea 2 - Configura Nginx para que desde tu m\u00e1quina anfitriona se tenga que tener tanto una IP v\u00e1lida como un usuario v\u00e1lido, ambas  cosas a la vez, y comprueba que s\u00ed puede acceder sin problemas.</p> <p>Modificamos de nuevo el archivo de configuraci\u00f3n /etc/nginx/sites-available/sitio-web, esta vez con la directiva satisfy all que  hace que tengamos que tener tanto IP como autenticaci\u00f3n correcta, para acceder a la p\u00e1gina web, as\u00ed que a\u00f1ade tu IP dentro de location  usando la directiva allow</p> <p></p> <p>El resultado de esto es que debemos tener una IP v\u00e1lida (es decir, dentro de nuestra subred) y que la autenticaci\u00f3n se realice correctamente.</p> <p></p> <p>Lo mismo ocurrir\u00e1 en contact.html, ya que la configuraci\u00f3n de este tambi\u00e9n est\u00e1 en la ra\u00edz del proyecto.</p> <p></p> <p>Reinicia el servidor y haz una prueba de acceso.</p> <p></p> <p>Si quisieramos que nadie en tu red tuviera acceso simplemente cambia el allow por deny.</p>"},{"location":"tema-2/practica2-2/#cuestionarios","title":"Cuestionarios","text":"<p>Cuesti\u00f3n 1</p> <p>Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio web_muy_guay de mi sitio web, equivoc\u00e1ndome al poner  el usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <p>No, debido a que la directiva satisfy all necesita que las credenciales sean las correctas y la IP v\u00e1lida, en este caso solo se cumple uno  de los dos requisitos, por lo que no podr\u00edas acceder. </p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy all;    \n    deny  172.1.10.6;\n    allow 172.1.10.15;\n    allow 172.1.3.14;\n    deny  all;\n    auth_basic \"Cuesti\u00f3n final 1\";\n    auth_basic_user_file conf/htpasswd;\n}\n</code></pre> <p>Cuesti\u00f3n 2</p> <p>ask \"Cuesti\u00f3n 1\" Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio web_muy_guay de mi sitio web,  introduciendo correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <p>Si, ya que cumples los dos requisitos, IP y autenticaci\u00f3n v\u00e1lidos.</p> <pre><code>   location /web_muy_guay {\n    #...\n    satisfy all;    \n    deny  all;\n    deny  172.1.10.6;\n    allow 172.1.10.15;\n    allow 172.1.3.14;\n\n    auth_basic \"Cuesti\u00f3n final 2: The revenge\";\n    auth_basic_user_file conf/htpasswd;\n} \n</code></pre> <p>Cuesti\u00f3n 3</p> <p>Supongamos que yo soy el cliente con la IP 172.1.10.15 e intento acceder al directorio web_muy_guay de mi sitio web, introduciendo  correctamente usuario y contrase\u00f1a. \u00bfPodr\u00e9 acceder?\u00bfPor qu\u00e9?</p> <p>En el caso de la directiva satisfy any, en principio, el cumplimiento de cualquiera de las condiciones permitir\u00eda el acceso a la web. Sin embargo, dado que la direcci\u00f3n IP est\u00e1 denegada y esta condici\u00f3n tiene prioridad sobre la autenticaci\u00f3n, el acceso ser\u00e1 restringido.</p> <pre><code>    location /web_muy_guay {\n    #...\n    satisfy any;    \n    deny  172.1.10.6;\n    deny 172.1.10.15;\n    allow 172.1.3.14;\n\n    auth_basic \"Cuesti\u00f3n final 3: The final combat\";\n    auth_basic_user_file conf/htpasswd;\n}\n</code></pre> <p>Cuesti\u00f3n 4</p> <p>A lo mejor no sab\u00e9is que tengo una web para documentar todas mis excursiones espaciales con Jeff, es esta: Jeff Bezos y yo</p> <p>Supongamos que quiero restringir el acceso al directorio de proyectos porque es muy secreto, eso quiere decir a\u00f1adir autenticaci\u00f3n  b\u00e1sica a la URL:Proyectos</p> <p>Completa la configuraci\u00f3n para conseguirlo:</p> <pre><code>    server {\n        listen 80;\n        listen [::]:80;\n        root /var/www/freewebsitetemplates.com/preview/space-science;\n        index index.html index.htm index.nginx-debian.html;\n        server_name freewebsitetemplates.com www.freewebsitetemplates.com;\n        location              {\n\n            try_files $uri $uri/ =404;\n        }\n    }\n</code></pre> <p>Tendr\u00edamos que a\u00f1adir un nuevo location con las l\u00edneas correspondientes a la autenticaci\u00f3n:</p> <pre><code>    {\n        location /Proyectos {\n            auth_basic \"\u00c1rea restringida\";\n            auth_basic_user_file /etc/nginx/.htpasswd;  \n        }\n    }\n</code></pre>"},{"location":"tema-2/practica2-3/","title":"Actividad 2.3 - Proxy inverso con Nginx","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 17/10/2024</p> <p>Curso: 2\u00ba de Desarrollo de Aplicaciones Web</p>"},{"location":"tema-2/practica2-3/#practica-23-proxy-inverso-con-nginx","title":"Pr\u00e1ctica 2.3 - Proxy Inverso con Nginx","text":""},{"location":"tema-2/practica2-3/#objetivo-de-la-practica-configurar-un-proxy-inverso-que-permitira-proteger-a-nuestro-servidor-de-los-clientes-evitando-posibles-ataques-ddos-al-servidor-de-esta-manera-la-ip-del-servidor-quedara-oculta-mientras-que-accederemos-a-los-proxys-que-se-encargaran-de-redireccionar-y-balancear-el-trafico-entre-varios-servidores","title":"Objetivo de la pr\u00e1ctica: Configurar un proxy inverso, que permitir\u00e1 proteger a nuestro servidor de los clientes, evitando posibles ataques DDoS al servidor. De esta manera, la IP del servidor quedar\u00e1 oculta mientras que accederemos a los proxys, que se encargar\u00e1n de redireccionar y balancear el tr\u00e1fico entre varios servidores.","text":""},{"location":"tema-2/practica2-3/#configuraciones","title":"Configuraciones","text":""},{"location":"tema-2/practica2-3/#servidor-web","title":"Servidor Web","text":"<p>Primero, vamos a clonar la m\u00e1quina virtual que contiene nuestro servidor Nginx, para crear un nuevo servidor que funcionar\u00e1 como proxy inverso.</p> <p>Para ello, haz click derecho sobre tu servidor Debian y selecciona Clonar, introduce el nombre de la nueva m\u00e1quina virtual, elige la carpeta donde se guardar\u00e1 y cambia la pol\u00edtica de direcci\u00f3n MAC seleccionando la opci\u00f3n Generar nuevas direcciones MAC para todos los adaptadores de red.</p> <p>Esto es importante para asegurar que el proxy y el servidor tengan IPs distintas, lo cual es necesario para la configuraci\u00f3n.</p> <p></p> <p>Cambia el nombre que tuviera el archivo de configuraci\u00f3n de nuestro servidor Nginx por el de webserver, el cual es una convenci\u00f3n para facilitar la administraci\u00f3n, usa el comando: sudo mv /etc/nginx/sites-available/nombre-servidor /etc/nginx/sites-available/webserver</p> <p></p> <p>Cambiar el nombre del sitio web dentro de este archivo de configuraci\u00f3n, para ello usa el comando  sudo nano /etc/nginx/sites-available/nombre-servidor, y modifica el nombre en la directiva server_name, </p> <p></p> <p>Ahora vamos a eliminar el link simb\u00f3lico antiguo con el comando unlink nombre_del_link dentro de la carpeta sites-enabled y crear el nuevo para el nuevo nombre de archivo.</p> <p>Eliminamos el anterior navegando hasta sites_enabled y usando el comando unlink, despu\u00e9s comprueba que no aparezca con ls -l</p> <p></p> <p>Creamos el nuevo enlace simb\u00f3lico.</p> <p></p> <p>En el archivo de configuraci\u00f3n del sitio web, en lugar de hacer que el servidor escuche en el puerto 80, cambiadlo al 8080, para acceder a el vuelve a introducir el comando sudo nano /etc/nginx/sites-available/webserver.</p> <p>Esto lo haremos para que todo quede m\u00e1s diferenciado y os quede m\u00e1s claro que la petici\u00f3n est\u00e1 pasando por el proxy inverso y llega al servidor web destino.</p> <p></p> <p>Reinicia Nginx para aplicar los cambios y comprueba el estado del servicio, sudo systemctl restart nginx y sudo systemctl status nginx.</p> <p></p>"},{"location":"tema-2/practica2-3/#nginx-proxy-inverso","title":"Nginx Proxy Inverso","text":"<p>Borramos el archivo de configuraci\u00f3n y el enlace simb\u00f3lico que fue clonado desde nuevo servidor, y lo sustituimos  por un nuevo archivo de configuraci\u00f3n que har\u00e1 que este nuevo servidor actue como proxy, comando sudo nano ejemplo-proxy</p> <p></p> <p>Hacemos el enlace simb\u00f3lico para que este archivo de configuraci\u00f3n se active, y que as\u00ed cuando hagamos el reinicio del servidor funcione.</p> <p></p> <p>Reiniciamos el servicio Nginx para surtir los cambios.</p> <p></p> <p>A\u00f1adimos al cliente la IP del proxy ejemplo-proxy junto a su server_name, accediendo a la ruta C:\\Windows\\System32\\drivers\\etc\\hosts, con esto ya deber\u00edamos poder acceder a la p\u00e1gina web mediante el proxy.</p> <p></p> <p>Comprobamos que podemos acceder desde el cliente al servidor backend a trav\u00e9s del proxy. Esto significa que el tr\u00e1fico web esta siendo correctamente dirigido desde el cliente al proxy, y el proxy est\u00e1 reenviando las solicitudes al servidor backend.</p> <p></p>"},{"location":"tema-2/practica2-3/#comprobaciones","title":"Comprobaciones","text":"<p>Verifica que todo funciona correctamente, usando las herramientas de an\u00e1lisis HTTP para inspeccionar las cabeceras de las solicitudes y respuesta.</p> <p>Para ello pulsa Control+Shift+C y dirigete a la pesta\u00f1a Red, sino te aparece nada refresca la p\u00e1gina con F5, despu\u00e9s selecciona el elemento con el nombre de tu servidor y comprueba que la solicitud devuelva 200 OK como c\u00f3digo de estado.</p> <p></p>"},{"location":"tema-2/practica2-3/#anadiendo-cabecera","title":"A\u00f1adiendo cabecera","text":"<p>A\u00f1adiendo nueva cabecera HTTP personalizada que contiene mi nombre. Esto es \u00fatil, por ejemplo, para agregar informaci\u00f3n adicional en las solicitudes que llegan al backend o simplemente para personalizar la respuesta del servidor.</p> <p></p> <p>Reiniciamos el servidor y al recargar la p\u00e1gina con el cliente deber\u00edamos de visualizar la nueva cabecera.</p> <p></p>"},{"location":"tema-2/practica2-4/","title":"Actividad 2.4 - Balanceo de carga con proxy inverso en Nginx","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 25/10/2024</p> <p>Curso: 2\u00ba de Desarrollo de Aplicaciones Web</p>"},{"location":"tema-2/practica2-4/#practica-24-balanceo-de-carga-con-proxy-inverso-en-nginx","title":"Pr\u00e1ctica 2.4 - Balanceo de carga con proxy inverso en Nginx","text":""},{"location":"tema-2/practica2-4/#objetivo-de-la-practica-configurar-nginx-como-proxy-inverso-y-balanceador-de-carga-para-distribuir-el-trafico-web-entre-varios-servidores-mejorando-eficiencia-disponibilidad-y-resiliencia-del-sitio-el-trafico-se-redirigira-aleatoriamente-entre-los-servidores-y-en-caso-de-fallo-de-uno-las-peticiones-se-enviaran-automaticamente-al-otro","title":"Objetivo de la pr\u00e1ctica: Configurar Nginx como proxy inverso y balanceador de carga para distribuir el tr\u00e1fico web entre varios servidores, mejorando eficiencia, disponibilidad y resiliencia del sitio. El tr\u00e1fico se redirigir\u00e1 aleatoriamente entre los servidores, y en caso de fallo de uno, las peticiones se enviar\u00e1n autom\u00e1ticamente al otro.","text":""},{"location":"tema-2/practica2-4/#configuracion-del-servidor-principal","title":"Configuraci\u00f3n del servidor principal","text":""},{"location":"tema-2/practica2-4/#importante-crea-un-nuevo-servidor-que-sea-una-clonacion-del-servidor-principal-con-la-opcion-activada-para-que-tengan-diferentes-ips","title":"Importante: Crea un nuevo servidor que sea una clonaci\u00f3n del servidor principal, con la opci\u00f3n activada para que tengan diferentes IPS.","text":"<p>Primero, debes desvincular el enlace simb\u00f3lico para que la plantilla de Nginx que hab\u00edamos configurado deje de visualizarse, para ello dirigete a la ruta /etc/nginx/sites-enabled con el comando cd /etc/nginx/sites-enabled y utiliza el comando unlink junto al nombre del archivo de configuraci\u00f3n de tu servidor.</p> <p></p> <p>Usa ls -l para verificar que el archivo est\u00e9 desvinculado.</p> <p></p> <p>Cambia el nombre de la carpeta que est\u00e1 dentro de /var/www/ para configurar el sitio web espec\u00edfico.</p> <p></p> <p>Accede a /var/www/webserver/html y crea el fichero index.html, con el comando sudo nano /var/www/webserver/html/index.html, despu\u00e9s a\u00f1ade el contenido que desees, en mi caso voy a usar un HTML muy b\u00e1sico que muestre el mensaje Este es el servidor web 1 para indicar que estamos accediendo al servidor principal.</p> <p></p> <p>Renombra la configuraci\u00f3n en /etc/nginx/sites-available</p> <p></p> <p>Edita el archivo de configuraci\u00f3n que acabamos de cambiar el nombre (/etc/nginx/sites-available/webserver), y especifica la ruta del directorio en la directiva root, para que muestre el nuevo index.html. Tambi\u00e9n, cambia el nombre en la directiva web_server y a\u00f1ade las IPs que podr\u00e1n acceder al servidor, los cuales van a ser el cliente, el servidor proxy y la m\u00e1quina clonada.</p> <p></p> <p>Creamos el nuevo enlace simb\u00f3lico, utilizando el comando ln -s /etc/nginx/sites-available/webserver /etc/nginx/sites-enabled, y luego confirma que est\u00e9 activo con ls -l. Ahora, el index.html del servidor principal deber\u00eda mostrarse.</p> <p></p> <p>Reiniciamos para guardar cambios con sudo systemctl restart nginx, despu\u00e9s verificamos la sintaxis en los archivos de configuraci\u00f3n con sudo nginx -t y revisamos el estado de Nginx con sudo systemctl status nginx.</p> <p></p>"},{"location":"tema-2/practica2-4/#configuracion-del-servidor-clonado","title":"Configuraci\u00f3n del servidor clonado","text":"<p>Repite el proceso anterior para configurar el servidor clonado, el cual recibir\u00e1 peticiones junto con el servidor principal.</p> <p>Desvincular el enlace simb\u00f3lico para que la plantilla de Nginx que hab\u00edamos configurado deje de visualizarse, para ello dirigete a la ruta /etc/nginx/sites-enabled con el comando cd /etc/nginx/sites-enabled y utiliza el comando unlink junto al nombre del archivo de configuraci\u00f3n de tu servidor.</p> <p></p> <p>Comprueba que haya funcionado con un ls -l</p> <p></p> <p>Cambia el nombre de la carpeta en /etc/nginx/sites-available y usa ln -s para crear un nuevo enlace simb\u00f3lico, comprobando despu\u00e9s que este activo.</p> <p></p> <p>Cambia el nombre de la carpeta que est\u00e1 dentro de /var/www/</p> <p></p> <p>Accede a /var/www/webserver/html y crea un fichero index.html, con el comando sudo nano /var/www/webserver/html/index.html, despu\u00e9s a\u00f1ade el contenido, en mi caso he a\u00f1adido otro HTML b\u00e1sico que ponga el mensaje Servidor Web 2, que indicar\u00e1 cu\u00e1ndo se redirige al servidor clonado.</p> <p></p> <p>Modificamos archivo de configuraci\u00f3n /etc/nginx/sites-available/webserver, estableciendo la ruta al nuevo index.html, cambiando el nombre en la directiva web_server, a\u00f1adiendo un encabezado HTTP y a\u00f1adiendo las IPs que podr\u00e1n acceder a este servidor.</p> <p></p> <p>Reiniciamos para guardar cambios, con el comando sudo systemctl restart nginx, despu\u00e9s realizamos las comprobaciones de sintaxis sudo nginx -t y ejecuci\u00f3n sudo systemctl status nginx para revisar el estado de Nginx y determinar que todo est\u00e9 correcto.</p> <p></p>"},{"location":"tema-2/practica2-4/#configuracion-del-proxy-inverso-para-balanceo-de-carga","title":"Configuraci\u00f3n del Proxy Inverso para balanceo de carga","text":"<p>Configuramos un nuevo archivo de configuraci\u00f3n  al cual llamar\u00e9 balanceo, este script permitir\u00e1 que las peticiones se distribuyan de forma aleatoria entre los dos servidores.</p> <p></p> <p>Deshacemos el enlace simb\u00f3lico anterior del proxy inverso, que ahora ser\u00e1 reemplazado por el archivo balanceo que permitir\u00e1 tanto balanceo de carga como proxy inverso.</p> <p></p> <p>Hacemos el enlace simb\u00f3lico, que vincula el archivo balanceo a sites_enabled.</p> <p></p> <p>Comprobamos sintaxis del archivo de configuraci\u00f3n, reiniciamos Nginx y despu\u00e9s mostramos su estado, para verificar que la configuraci\u00f3n sea correcta y est\u00e9 activa.</p> <p></p> <p>Edita el archivo de configuraci\u00f3n C:\\Windows\\system32\\drivers\\hosts para permitir el acceso al dominio configurado como proxy (www.balanceo.com), el cual distribuir\u00e1 las peticiones, as\u00ed como a las direcciones IP de los servidores backend a los cuales el proxy redirigir\u00e1 las solicitudes.</p> <p></p> <p>Resultado al entrar en *www.backend_hosts.com</p>"},{"location":"tema-2/practica2-4/#comprobaciones-servidor-1","title":"Comprobaciones Servidor 1","text":"<p>Ahora es el momento de comprobar el resultado, accede al server_name de tu servidor proxy desde el navegador del cliente, y este deber\u00e1 de reenviarte a uno de los dos servidores de forma aleatoria, en mi caso mi server_name es *www.balance.com.</p> <p></p>"},{"location":"tema-2/practica2-4/#comprobaciones-servidor-2","title":"Comprobaciones Servidor 2","text":"<p>Tras recargar una o varias veces nos aparecer\u00e1 nuestro otro servidor.</p> <p></p>"},{"location":"tema-2/practica2-4/#comprobacion-del-balanceo-de-carga-cuando-cae-un-servidor","title":"Comprobaci\u00f3n del balanceo de carga cuando cae un servidor","text":"<p>Paramos el servidor 2, es decir, el clon  con el comando sudo systemctl stop nginx y comprobamos que todas las peticiones ahora pasan por el servidor principal.</p> <p></p> <p></p> <p>Ahora vamos a hacer lo mismo, pero con el servidor principal, paralo e inicia de nuevo el servidor clonado con el comando sudo systemctl start nginx</p> <p></p> <p></p> <p>Al parar el servicio Nginx que controla nuestro servidor web, las peticiones dejar\u00e1n de poder pasar por ese servidor y ser\u00e1n todas reenviadas al servidor que funciona correctamente.</p>"},{"location":"tema-2/practica2-4/#cuestiones-finales","title":"Cuestiones finales","text":""},{"location":"tema-2/practica2-4/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Busca informaci\u00f3n de qu\u00e9 otros m\u00e9todos de balanceo se pueden aplicar con Nginx y describe al menos 3 de ellos.</p> <p>NGINX ofrece varios m\u00e9todos de balanceo de carga:</p> <ul> <li> <p>Round Robin: Este m\u00e9todo, es sencillo y el m\u00e1s usado, se encarga de enviar aleatoriamente a distintos servidores las peticiones de los clientes, es ideal cuando los servidores tienen recursos muy parecidos.</p> </li> <li> <p>Conexiones m\u00ednimas: M\u00e9todo din\u00e1mico que dirige las nuevas peticiones al servidor con menos conexiones, es \u00fatil cuando los servidores tienen distintas capacidades, ayudando a evitar la sobrecarga de peticiones.</p> </li> <li> <p>Hash de IP: La direcci\u00f3n IP del cliente se usa como clave para determinar el servidor que debe gestionar la petici\u00f3n del cliente, asegurando que todas las peticiones de un cliente espec\u00edfico se envi\u00e9n siempre al mismo servidor. Este m\u00e9todo es ideal para aplicaciones de redes sociales, ya que facilita conexiones persistentes, mejorando la consistencia de la experiencia del usuario.</p> </li> </ul>"},{"location":"tema-2/practica2-4/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>Si quiero a\u00f1adir 2 servidores web m\u00e1s al balanceo de carga, describe detalladamente qu\u00e9 configuraci\u00f3n habr\u00eda que a\u00f1adir y d\u00f3nde.</p> <p>Solo debes a\u00f1adir los dos servidores al archivo de configuraci\u00f3n de nuestro servidor proxy, en este caso el archivo de configuraci\u00f3n de balanceo. Para esto, abre el archivo de configuraci\u00f3n de Nginx correspondiente y localiza el bloque upstream que define el grupo de servidores backend. Agrega las direcciones IP de los dos nuevos servidores dentro de este bloque, guarda los cambios y reinicia el servicio de Nginx para aplicar la nueva configuraci\u00f3n.</p> <p>Despu\u00e9s, aseg\u00farate de que el sistema cliente puede resolver los nombres de los nuevos servidores agregando sus direcciones IP y nombres en el archivo hosts del cliente. En Windows, el archivo hosts se encuentra en C:\\Windows\\System32\\drivers\\etc\\hosts. Al final de este archivo, a\u00f1ade una l\u00ednea para cada nuevo servidor con el formato IP direcci\u00f3n servidor_nombre.</p> <p>Esto permitir\u00e1 que el cliente pueda acceder correctamente a los nuevos servidores.</p>"},{"location":"tema-2/practica2-4/#cuestion-3","title":"Cuesti\u00f3n 3","text":"<p>Describe todos los pasos que deber\u00edamos seguir y configurar para realizar el balanceo de carga con una de las webs de pr\u00e1cticas anteriores. Indicad la configuraci\u00f3n de todas las m\u00e1quinas (webservers, proxy...) y de sus servicios</p> <p>En los servidores web, se debe modificar la directiva server_name.</p> <p>En el servidor proxy, se crear\u00e1 un nuevo archivo de configuraci\u00f3n donde se definir\u00e1 un bloque upstream que incluya las direcciones IP de cada servidor web. Esto permitir\u00e1 que el balanceador de carga conozca qu\u00e9 servidores est\u00e1n disponibles para manejar las solicitudes.</p> <p>Adem\u00e1s, se a\u00f1adir\u00e1 la directiva proxy_pass dentro del bloque server para redirigir las solicitudes hacia el grupo de servidor definidos en el bloque upstream.</p>"},{"location":"tema-2/practica2-5/","title":"Actividad 2.5 - Proxy inverso y balanceo de carga con SSL en NGINX","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 02/11/2024</p> <p>Curso: 2\u00ba de Desarrollo de Aplicaciones Web</p>"},{"location":"tema-2/practica2-5/#practica-25-proxy-inverso-y-balanceo-de-carga-con-ssl-en-nginx","title":"Pr\u00e1ctica 2.5 - Proxy inverso y balanceo de carga con SSL en NGINX","text":""},{"location":"tema-2/practica2-5/#creacion-de-certificado-autofirmado","title":"Creaci\u00f3n de certificado autofirmado","text":"<p>Creamos una carpeta llamada ssl dentro del directorio /etc/nginx/, este es un lugar com\u00fan para almacenar los archivos de certificados y clave de SSL en servidores Nginx, facilitando la administraci\u00f3n y organizaci\u00f3n.</p> <p></p> <p>Generamos un certificado SSL autofirmado y lo colocamos dentro de la carpeta /etc/nginx/ssl, un certificado autofirmado es \u00fatil para pruebas y entornos de desarrollo, ya que permite habilitar HTTPS sin tener que obtener un certificado de una autoridad de certificaci\u00f3n (CA).</p> <p>El certificado y la clave se generan mediante comandos como openssl y suelen guardarse como archivos .crt (certificado) y .key (clave privada)</p> <p></p>"},{"location":"tema-2/practica2-5/#configuracion-ssl-en-el-proxy-inverso","title":"Configuraci\u00f3n SSL en el proxy inverso","text":"<p>En nuestro servidor proxy cambiamos la configuraci\u00f3n de nuestro archivo de configuraci\u00f3n /etc/nginx/sites-available/balanceo para incluir las configuraciones necesarias para SSL:</p> <ul> <li> <p>listen 443 ssl; : Hace que Nginx escuche en el puerto 443 (el est\u00e1ndar para HTTPS) y active SSL.</p> </li> <li> <p>ssl_certificate y ssl_certificate_key : Estas l\u00edneas especifican las rutas del certificado y la clave privada que generaste.</p> </li> <li> <p>ssl_protocols y ssl_ciphers : Estas l\u00edneas configuran los protocolos y cifrados permitidos para SSL, ayudando a asegurar las conexiones HTTPS.</p> </li> </ul> <p></p> <p>Comprobamos que la sintaxis del archivo sea correcta y reiniciamos el servidor para aplicar los cambios.</p> <p></p>"},{"location":"tema-2/practica2-5/#comprobaciones","title":"Comprobaciones","text":"<p>Despu\u00e9s de configurar el proxy inverso con SSL, prueba acceder al sitio mediante HTTPS.</p> <p>El certificado al estar autofirmado los navegadores podr\u00edan mostrar una advertencia, a pesar de que el tr\u00e1fico entre el cliente y el servidor est\u00e9 encriptado.</p> <p></p> <p>Comprobaci\u00f3n de que podemos acceder a la p\u00e1gina web y vemos el certificado.</p> <p></p> <p></p>"},{"location":"tema-2/practica2-5/#redireccion-forzora-a-https","title":"Redirecci\u00f3n forzora a HTTPS","text":"<p>Configuramos una redirecci\u00f3n autom\u00e1tica de HTTP a HTTPS. Esto se logra a\u00f1adiendo un bloque server separado en el archivo de configuraci\u00f3n Nginx, que redirigir\u00e1 todo el tr\u00e1fico que intente acceder por el puerto 80 (HTTP) a ese puerto al puerto 443 (HTTPS). para ello a\u00f1ade en el archivo de configuraci\u00f3n:</p> <ul> <li> <p>listen 80</p> </li> <li> <p>server_name</p> </li> <li> <p>return 301 https://$host$request_uri : Realiza una redirecci\u00f3n 301 permanente a la versi\u00f3n HTTPS del sitio. El $host y $request_uri garantizan que la redirecci\u00f3n se mantenga en la misma URL a la que el usuario intent\u00f3 acceder, pero usando HTTPS.</p> </li> </ul> <p></p> <p>Comprobamos la sintaxis y reiniciamos para que los cambios surjan efecto.</p> <p></p>"},{"location":"tema-2/practica2-5/#tareas","title":"Tareas","text":"<ul> <li>Eliminad del otro bloque server {..} las l\u00edneas que hagan referencia a escuchar en el puerto 80 (listen 80...).</li> </ul> <p>Eliminar el puerto de escucha 80 del archivo de configuraci\u00f3n har\u00e1 que todos los intentos de entrada por puertos que no sean el 443 sean redirigidos a este.</p> <p></p> <ul> <li>Reiniciad el servicio.</li> </ul> <p></p> <ul> <li>Comprobad ahora que cuando entr\u00e1is en http://balanceo, autom\u00e1ticamente os redirige a la versi\u00f3n segura de la web.</li> </ul> <p>La configuraci\u00f3n usada asegura que los usuarios siempre accedan a la versi\u00f3n segura del sitio sin importar c\u00f3mo escriban la URL en sus navegadores, en mi caso escrib\u00ed http://www.balanceo.com</p> <p></p> <ul> <li>Comprobad que cuando realiz\u00e1is una petici\u00f3n en el archivo de log http_access.log aparece la redirecci\u00f3n 301 y que, de la misma manera, aparece una petici\u00f3n GET en https_access.log</li> </ul> <p>En este archivo se registran las solicitudes que llegan al bloque HTTP (puerto 80) y son redirigidas a HTTPS. En este archivo, deber\u00edan aparecer registros de c\u00f3digo 301, indicando la redirecci\u00f3n, as\u00ed como las peticiones GET que se realizaron a la versi\u00f3n HTTPS del sitio.</p> <p></p>"},{"location":"tema-2/practica2-5/#cuestionario","title":"Cuestionario","text":""},{"location":"tema-2/practica2-5/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Hemos configurado nuestro proxy inverso con todo lo que nos hace falta pero no nos funciona y da un error de tipo This site can't provide a secure connection ERR_SSL_PROTOCOL_ERROR.</p> <p>Dentro de nuestro server block tenemos esto:</p> <pre><code>server {\n    listen 443;\n    ssl_certificate /etc/nginx/ssl/enrico-berlinguer/server.crt;\n    ssl_certificate_key /etc/nginx/ssl/enrico-berlinguer/server.key;\n    ssl_protocols TLSv1.3;\n    ssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS;\n    server_name enrico-berlinguer;\n    access_log /var/log/nginx/https_access.log;\n\n    location / {\n        proxy_pass http://red-party;\n        }\n    }\n</code></pre> <p>Falta el ssl en la segunda l\u00ednea despu\u00e9s de listen 443</p>"},{"location":"tema-2/practica2-5/#cuestion-2","title":"Cuesti\u00f3n 2","text":"<p>Imaginad que intentamos acceder a nuestro sitio web HTTPS y nos encontramos con el siguiente error:</p> <p></p> <p>Investigad qu\u00e9 est\u00e1 pasando y como se ha de solucionar.</p> <p>Este error ocurre cuando el certificado SSL del sitio web se encuentra caducado, ha sido revocado por alguna raz\u00f3n, como una vulnerabilidad o el certificado no est\u00e1 configurado correctamente en el servidor.</p> <p>Como posibles soluciones tenemos:</p> <ul> <li> <p>Renovar el certificado.</p> </li> <li> <p>Contactar al proveedor de certificados si el certificado ha sido revocado, para obtener m\u00e1s detalles y resolver el problema.</p> </li> <li> <p>Revisar la configuraci\u00f3n del servidor y reinicia el servidor, para asegurarte de que el certificado est\u00e9 configurado correctamente en el servidor y se est\u00e9n aplicando los cambios del archivo de configuraci\u00f3n actualmente.</p> </li> </ul>"},{"location":"tema-2/practica2-6/","title":"Pr\u00e1ctica 2.6 (Ampliaci\u00f3n) - Configuraci\u00f3n de un servidor Nginx con Hosts Virtuales y directorios de usuario","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 12/12/2024</p> <p>Curso: 2\u00ba de Desarrollo de Aplicaciones Web</p>"},{"location":"tema-2/practica2-6/#practica-41-configuracion-de-un-servidor-nginx-con-host-virtuales-y-directorios-de-usuario","title":"Pr\u00e1ctica 4.1: Configuraci\u00f3n de un servidor Nginx con Host Virtuales y directorios de usuario","text":"<p>El objetivo de esta pr\u00e1ctica est\u00e1 en la configuraci\u00f3n de un servidor Nginx que utilice host virtuales para alojar m\u00faltiples sitios web en un solo servidor y que cada host virtual apunte al directorio public_hml de distintos usuarios del sistema operativo Debian. De esta manera, cada usuario podr\u00e1 gestionar su propio sitio web desde su carpeta personal.</p> <p>Lo primero que debemos hacer es instalar el servidor Nginx y comprobar que su servicio est\u00e1 funcionando correctamente.</p> <p></p> <p>A continuaci\u00f3n, permitimos el tr\u00e1fico en los puertos 80 (HTTP) y 22 (SSH) para permitir el acceso a las p\u00e1ginas web.</p> <p></p>"},{"location":"tema-2/practica2-6/#conexion-al-servidor","title":"Conexi\u00f3n al servidor","text":"<p>Para conectarnos por SSH desde nuestra m\u00e1quina anfitriona, debemos de instalar el paquete openssh-server en nuestro servidor virtual Debian.</p> <p></p> <p>Una vez instalado, abrimos la terminal y nos conectamos a ella, mediante el comando ssh nombre-usuario@IP.</p> <p></p>"},{"location":"tema-2/practica2-6/#usuarios-y-carpetas","title":"Usuarios y carpetas","text":""},{"location":"tema-2/practica2-6/#creacion-de-usuarios-carpetas-y-pagina-web-estatica","title":"Creaci\u00f3n de usuarios, carpetas y p\u00e1gina web est\u00e1tica","text":"<p>A\u00f1adimos los dos usuarios y le introducimos su nueva contrase\u00f1a segura, comandos sudo useradd -m -s /bin/bash nombre-usuario y sudo passwd nombre-usuario, la opci\u00f3n -m crea un directorio home para el nuevo usuario, mientras que -s crea una shell de inicio.</p> <p></p> <p>Accedemos con el primer usuario, creamos su carpeta y le asignamos sus permisos correspondientes sobre esa carpeta, el \u00faltimo comando es para validar los permisos sobre la carpeta.</p> <p></p> <p>Creamos una p\u00e1gina web b\u00e1sica en formato HTML dentro de la carpeta reci\u00e9n creada. Esta p\u00e1gina se utilizar\u00e1 como sitio web est\u00e1tico del usuario.</p> <p></p>"},{"location":"tema-2/practica2-6/#repeticion-de-los-mismos-pasos-para-el-segundo-usuario","title":"Repetici\u00f3n de los mismos pasos para el segundo usuario","text":"<p>Repetimos el proceso de creaci\u00f3n de carpeta, asignaci\u00f3n de permisos y creaci\u00f3n de la p\u00e1gina web est\u00e1tica para el segundo usuario.</p> <p></p> <p></p> <p>Comprobamos que nuestra p\u00e1gina web se visualiza correctamente con nuestro archivo de configuraci\u00f3n.</p> <p></p> <p>Resultado.</p> <p></p>"},{"location":"tema-2/practica2-6/#configuracion-de-certificados-ssl","title":"Configuraci\u00f3n de certificados SSL","text":"<p>Para mejorar la seguridad de las p\u00e1ginas web de los usuarios, creamos certificados SSL para ambos sitios web.</p> <p></p> <p></p>"},{"location":"tema-2/practica2-6/#archivos-de-configuracion-de-nginx","title":"Archivos de Configuraci\u00f3n de Nginx","text":"<p>Configuramos los archivos correspondientes para que Nginx sirva correctamente los sitios web de los usuarios. A continuaci\u00f3n, mostramos las configuraciones realizadas para cada usuario:</p> <p></p> <p></p>"},{"location":"tema-2/practica2-6/#creacion-de-enlaces-simbolicos-y-reinicio-del-servidor","title":"Creaci\u00f3n de Enlaces Simb\u00f3licos y Reinicio del Servidor","text":"<p>Creamos los enlaces simb\u00f3licos para que Nginx apunte a los directorios de los usuarios y sus respectivas p\u00e1ginas web. Despu\u00e9s de crear los enlaces, comprobamos la sintaxis de la configuraci\u00f3n y reiniciamos el servidor para aplicar los cambios.</p> <p></p> <p>Tambi\u00e9n permitimos el tr\u00e1fico en el puerto 443, que es utilizado para HTTPS.</p> <p></p>"},{"location":"tema-2/practica2-6/#resultados","title":"Resultados","text":"<p>Una vez completada la configuraci\u00f3n, verificamos el funcionamiento de las p\u00e1ginas web de ambos usuarios:</p> <p>Resultado con el usuario Antonio.</p> <p></p> <p></p> <p></p> <p>Resultado con el usuario Sergio.</p> <p></p> <p></p> <p></p>"},{"location":"tema-3/practica3-1/","title":"Actividad 3.1 - Instalaci\u00f3n de Tomcat","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 17/11/2024</p> <p>Curso: 2\u00ba de Desarrollo de Aplicaciones Web</p>"},{"location":"tema-3/practica3-1/#practica-31-instalacion-de-tomcat","title":"Pr\u00e1ctica 3.1 - Instalaci\u00f3n de Tomcat","text":""},{"location":"tema-3/practica3-1/#instalacion-y-configuracion-de-tomcat","title":"Instalaci\u00f3n y configuraci\u00f3n de Tomcat","text":"<p>Antes de empezar, usa el comando sudo ufw allow 8080 que permite el tr\u00e1fico a trav\u00e9s del puerto 8080, el cual es el puerto predeterminado en el que Apache Tomcat escucha las solicitudes HTTP, despu\u00e9s usa sudo ufw enable para habilitar el firewall ufw y configurarlo para que se inicie autom\u00e1ticamente al arrancar el sistema, por \u00faltimo, instala el paquete openjdk-17-jdk, que contiene el kit de Desarrollo de Java, necesario para ejecutar aplicaciones Java.</p> <p></p> <p></p> <p>Instala el paquete que contiene Tomcat, con el comando sudo apt install tomcat10.</p> <p></p> <p>Instala Java Runtime Environment (JRE) que incluye el entorno necesario para ejecutar aplicaciones y programas desarrollados en Java, utiliza el comando sudo apt install default-jre.</p> <p></p> <p>Comprobamos que se hayan instalado correctamente tanto Tomcat como Java JRE, para ello utiliza los comandos java -version y sudo systemctl status tomcat.</p> <p></p> <p>Accede al fichero tomcat-users.xml perteneciente a la ruta /etc/tomcat10/ y a\u00f1ade al nuevo usuario con los roles que aparecen en la imagen para otorgarle permisos administrativos y de gesti\u00f3n en Tomcat.</p> <p></p>"},{"location":"tema-3/practica3-1/#acceso-a-tomcat","title":"Acceso a Tomcat","text":"<p>Para poder acceder a la aplicaci\u00f3n web de administraci\u00f3n de Tomcat, necesitamos descargar el paquete tomcat-admin.</p> <p></p> <p>Comprobamos que ahora podemos acceder a la interfaz administrativa introduciendo en el navegador localhost:8080/manager/html.</p> <p></p> <p>Accedemos al gestor de aplicaciones web de Tomcat, introduciendo en el navegador localhost:8080/manager/html.</p> <p></p> <p>Si intentamos entrar al gestor de host virtuales con este usuario, nos encontraremos el siguiente error, por falta del rol admin-gui.</p> <p></p>"},{"location":"tema-3/practica3-1/#despliegue","title":"Despliegue","text":"<p>Subimos el archivo sample.war en localhost:8080/manager/html y pulsamos el bot\u00f3n Desplegar, el contenido de sample.war ser\u00e1 descomprimido y sus contenidos se copiar\u00e1n en un nuevo directorio bajo webapps de Tomcat, ejecutando tambi\u00e9n el archivo web.xml para inicializar y configurar la aplicaci\u00f3n web seg\u00fan las especificaciones de sample.war.</p> <p></p> <p>Resultado</p> <p></p>"},{"location":"tema-3/practica3-1/#despliegue-con-maven","title":"Despliegue con Maven","text":"<p>Ejecuta el comando sudo apt install maven para instalar el paquete Maven, utilizado como herramienta de gesti\u00f3n y comprensi\u00f3n de proyectos Java, para gestionar dependencias.</p> <p></p> <p>Muestra que Maven ha sido instalado correctamente con el comando mvn --v.</p> <p></p> <p>Creamos un nuevo usuario en el archivo de configuraci\u00f3n tomcat-user.xml que ser\u00e1 utilizado para scripts de administraci\u00f3n.</p> <p></p> <p>Entra al fichero settings.xml dentro de /etc/maven y define un perfil de autenticaci\u00f3n para Maven, que ser\u00e1 utilizado cuando Maven quiera conectarse a servidores remotos.</p> <p></p> <p>Ve al directorio donde deseas crear tu proyecto y utiliza el comando mvn archetype:generate -DgroupId=com.ejemplo -DartifactId=mi-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false que generar\u00e1 un proyecto Maven, es decir, un nuevo proyecto Java con una estructura b\u00e1sico, incluyendo el archivo pom.xml.</p> <p></p> <p>Modifica el archivo pom.xml para incluir las dependencias y plugins necesarios.</p> <p></p> <p></p> <p>Nos movemos a la ra\u00edz del proyecto y ejecutamos el comando tomcat7:deploy para desplegarlo.</p> <p></p> <p></p> <p>El directorio nos aparecer\u00e1 en las aplicaciones de localhost8080:manager/html y podremos acceder a \u00e9l, visualizando su resultado.</p> <p></p> <p></p>"},{"location":"tema-3/practica3-1/#tareas","title":"Tareas","text":"<p>Instala Git, ya que lo vas a necesitar para clonar un repositorio, comando sudo apt install git</p> <p></p> <p>Enlazamos con nuestro GitHub.</p> <p></p> <p>Clonamos un repositorio, comando git clone.</p> <p></p> <p>Cambiamos a la rama patch-1 dentro del repositorio clonado, comando git checkout patch-1.</p> <p></p> <p>Editamos el archivo pom.xml del repositorio clonado y a\u00f1adimos la configuraci\u00f3n para que se pueda desplegar la nueva aplicaci\u00f3n.</p> <p></p> <p></p> <p>Desplegamos la nueva aplicaci\u00f3n, con el comando mvn tomcat7:deploy.</p> <p></p> <p></p> <p>Revisamos que la nueva aplicaci\u00f3n aparece junto a las aplicaciones despegadas y la probamos.</p> <p></p> <p></p>"},{"location":"tema-3/practica3-1/#cuestiones","title":"Cuestiones","text":"<p>Hab\u00e9is visto que los archivos de configuraci\u00f3n que hemos tocado contienen contrase\u00f1as en texto plano, por lo que cualquiera con acceso a ellos obtendr\u00eda las credenciales de nuestras herramientas.</p> <p>En principio esto representa un gran riesgo de seguridad, \u00bfsabr\u00edas razonar o averig\u00fcar por qu\u00e9 esto est\u00e1 dise\u00f1ado de esta forma?</p> <p>Debido a la facilidad de uso y configuraci\u00f3n que el texto plano aporta, y su alta compatibilidad con sistemas.</p>"},{"location":"tema-3/practica3-2/","title":"Actividad 3.2 - Despiegue de Aplicaciones con Node Express y Netify","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 21/11/2024</p> <p>Curso: 2\u00ba de Desarrollo de Aplicaciones Web</p>"},{"location":"tema-3/practica3-2/#practica-32-despliegue-de-aplicaciones-con-node-express","title":"Pr\u00e1ctica 3.2: Despliegue de aplicaciones con Node Express","text":""},{"location":"tema-3/practica3-2/#introduccion","title":"Introducci\u00f3n","text":"<p>Det\u00e9n el servicio de Tomcat para evitar problemas, con el comando sudo systemctl stop tomcat10.service.</p> <p></p>"},{"location":"tema-3/practica3-2/#instalacion-de-nodejs-express-y-test-de-la-primera-aplicacion","title":"Instalaci\u00f3n de Node.js, Express y test de la primera aplicaci\u00f3n","text":"<p>Actualizamos los repositorios de la m\u00e1quina virtual, con el comando sudo apt update.</p> <p></p> <p>Instalamos los repositorios nodejs y npm para poder despu\u00e9s instalar y utilizar el plugin express.js, para ello usa el comando sudo apt -y install nodejs npm.</p> <p></p> <p>Comprobaci\u00f3n de que se han instalado correctamente.</p> <p></p> <p>Usando npm instalamos el plugin express, comando sudo npm install -g express.</p> <p></p> <p>Crea un nuevo repositorio, accede a \u00e9l e inicializa un nuevo proyecto usando npm.</p> <p></p> <p>Instala express para este proyecto local, comando npm install express.</p> <p></p> <p>Crea el archivo de muestra app.js y accede al archivo que se habr\u00e1 creado al inicializar el proyecto y a\u00f1ade el contenido que aparece a continuaci\u00f3n.</p> <pre><code>const express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/', (req, res) =&gt; {\n    res.send('Hello. Welcome to this blog')\n})\n\napp.listen(port, () =&gt; {\n    console.log(`Example app listening at http://localhost:${port}`)\n})\n</code></pre> <p></p> <p>Despliega el proyecto con el comando node app.js y visualiza los resultados.</p> <p></p> <p></p>"},{"location":"tema-3/practica3-2/#despliegue-de-una-nueva-aplicacion","title":"Despliegue de una nueva aplicaci\u00f3n","text":"<p>Vamos ahora a realizar el despliegue de una aplicaci\u00f3n de terceros para ver c\u00f3mo es el proceso.</p> <p>Clonar el repositorio a nuesta m\u00e1quina, con el comando git clone https://github.com/contentful/the-example-app.nodejs.git:</p> <p></p> <p>Instalamos las librerias necesarias, para ello introduce el comando npm install y vuelve en 10 minutos.</p> <p></p> <p>Despliega la aplicaci\u00f3n web con el comando npm run start:dev.</p> <p></p> <p></p>"},{"location":"tema-3/practica3-2/#cuestiones","title":"Cuestiones","text":"<p>Cuando ejecut\u00e1is el comando npm run start:dev, lo que est\u00e1is haciendo es ejecutar un script:</p> <p>\u00bfDonde podemos ver que script se est\u00e1 ejecutando?</p> <p>En el archivo package.json de tu proyecto.</p> <p>\u00bfQu\u00e9 comando est\u00e1 ejecutando?</p> <p>Esta ejecutando el comando node ./bin/www.</p> <p></p>"},{"location":"tema-3/practica3-2/#practica-34-despliegue-de-una-aplicacion-react-en-netlify-paas","title":"Pr\u00e1ctica 3.4: Despliegue de una aplicaci\u00f3n React en Netlify (PaaS)","text":"<p>Nos crearemos un directorio para albergar la aplicaci\u00f3n con el nombre que queramos. En ese directorio, crearemos los 3 archivos (dos .html y un .js) que conformar\u00e1n nuestra sencilla aplicaci\u00f3n de ejemplo:</p> <p></p>"},{"location":"tema-3/practica3-2/#creacion-de-nuestra-aplicacion","title":"Creaci\u00f3n de nuestra aplicaci\u00f3n","text":"<p>Al primer archivo lo llamar\u00e9 head.html y tendr\u00e1 el siguiente contenido:</p> <p></p> <p>El segundo ser\u00e1 llamado tail.html.</p> <p></p> <p>El script ser\u00e1 llamado aplicacion.js.</p> <p></p> <p>Como hacemos siempre a la hora de crear una apliaci\u00f3n usando Node.js, inicializamos el proyecto, con el comando npm init.</p> <p></p> <p>Corremos el programa para probar en local que funciona perfectamente, comando node aplicacion.js.</p> <p></p> <p></p> <p></p> <p>En package.json sustituye la l\u00ednea dentro del bloque script a\u00f1adiendo la l\u00ednea de \"start\": \"node aplicacion.js\" para evitar problemas y que nos funcione en la plataforma PaaS.</p> <p></p>"},{"location":"tema-3/practica3-2/#aplicacion-para-netlify","title":"Aplicaci\u00f3n para Netlify","text":"<p>Puesto que el inter\u00e9s en este m\u00f3dulo radica en el proceso de despliegue, suponiendo que la parte de desarrollo ya es abordada en otros m\u00f3dulos, vamos a utilizar una aplicaci\u00f3n de ejemplo que nos ahorre tiempo para centrarnos en el despliegue.</p> <p>Clonamos el repositorio color-shades-generator.</p> <p></p>"},{"location":"tema-3/practica3-2/#proceso-de-despliegue-en-netlify","title":"Proceso de despliegue en Netlify","text":""},{"location":"tema-3/practica3-2/#despliegue-mediante-cli","title":"Despliegue mediante CLI","text":"<p>Instalamos el CLI de Netlify netlify-cli.</p> <p></p> <p>Iniciamos sesi\u00f3n en Netlify, comando netlify login.</p> <p></p> <p>Vete a tu perfil, entra en OAuth y crea una nueva clave de acceso.</p> <p></p> <p>Copiamos y guardamos el token devuelto.</p> <p></p> <p>Exportamos el token y lo establecemos como variable de entorno.</p> <p></p> <p>Volvemos a iniciar sesi\u00f3n.</p> <p></p> <p>Bueno, tenemos el c\u00f3digo de nuestra aplicaci\u00f3n, tenemos nuestra cuenta en Netlify y tenemos el CLI necesario para ejecutar comandos desde el terminal en esa cuenta... \u00bfPodemos proceder al despliegue sin mayores complicaciones?</p> <p>La respuesta es NO, como buenos desarrolladores y en base a experiencias anteriores, ya sab\u00e9is que hay que hacer un build de la aplicaci\u00f3n para, posteriormente, desplegarla. Vamos a ello.</p> <p>En primer lugar, como sabemos, debemos instalar todas las dependencias que vienen indicadas en el archivo package.json:</p> <p>Instalamos npm, comando npm install.</p> <p></p> <p>Creamos una versi\u00f3n del proyecto optimizada para producci\u00f3n, con el comando npm run build.</p> <p></p> <p>Desplegamos el proyecto usando Netlify con el comando netlify deploy.</p> <p></p> <p>Accede a la URL que aparece en Website draft URL.</p> <p></p> <p></p> <p>Desplegamos de nuevo, pero esta vez usando netlify deploy --prod, para obtener una url m\u00e1s clara.</p> <p></p> <p>Accede a la URL que aparece en Website URL.</p> <p></p>"},{"location":"tema-3/practica3-2/#despliegue-mediante-conexion-con-github","title":"Despliegue mediante conexi\u00f3n con Github","text":"<p>Borramos nuestro sitio de Netlify para evitar cualquier problema o conflicto.</p> <p></p> <p>Eliminamos nuestro directorio personal color-shades-generator, para as\u00ed poder empezar de 0, comando rm -rf.</p> <p></p> <p>Clonar nuevo proyecto con wget https://github.com/StackAbuse/color-shades-generator/archive/refs/heads/main.zip.</p> <p></p> <p>Crea un nuevo repositorio y descomprime lo descargado anteriormente con wget, comando unzip para descomprimir.</p> <p></p> <p>Crea un nuevo repositorio en GitHub.</p> <p></p> <p>Inicializa el repositorio personal descargado.</p> <p></p> <p>Haz un nuevo commit con los cambios.</p> <p></p> <p>Referencia la carpeta local con el repositorio reci\u00e9n creado en github, con el comando git remote add y despu\u00e9s introduce git push -u origin main para subir el contenido del commit.</p> <p></p> <p>Importa el repositorio creado en Github desde Netlify.</p> <p></p> <p>Le indicamos que no acceda a todos nuestros repositorios sino s\u00f3lo al repositorio que necesitamos.</p> <p></p> <p>Introducimos el nombre de nuestro sitio y desplegamos la aplicaci\u00f3n.</p> <p></p> <p></p> <p>Cuando finalice el despliegue cambia el nombre de tu sitio web a\u00f1adi\u00e9ndole tu nombre.</p> <p></p> <p>Lo que hemos conseguido de esta forma es que, cualquier cambio que hagamos en el proyecto y del que hagamos commit y push en Github, autom\u00e1ticamente genere un nuevo despliegue en Netlify. Es el principio de lo que m\u00e1s adelante veremos como despliegue continuo.</p> <p>Comprueba si puedes acceder al archivo robots.txt desde el navegador utilizando la URL de tu sitio en Netlify.</p> <p></p> <p>Modificar archivo robots.txt para que incluya tu nombre, este archivo est\u00e1 dentro de la carpeta public.</p> <p></p> <p>Haz un nuevo commit y push, para subir los cambios realizados en el archivo robot.txt a tu repositorio de GitHub.</p> <p></p> <p>Comprueba en el dashboard de Netlify que se ha producido un nuevo deploy de la aplicaci\u00f3n hace escasos segundos</p> <p></p> <p>Accede a robots.txt desde el navegador y comprueba que, efectivamente, se ve reflejado el cambio.</p> <p></p>"},{"location":"tema-3/practica3-3/","title":"Pr\u00e1ctica 3.3 - Despliegue de una aplicaci\u00f3n Flask (Python)","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 22/11/2024</p> <p>Curso: 2\u00ba de Desarrollo de Aplicaciones Web</p>"},{"location":"tema-3/practica3-3/#practica-33-despliegue-de-una-aplicacion-flaskpython","title":"Pr\u00e1ctica 3.3: Despliegue de una aplicaci\u00f3n Flask(Python)","text":""},{"location":"tema-3/practica3-3/#procedimiento-completo-para-el-despliegue","title":"Procedimiento completo para el despliegue","text":"<p>Primero actualizamos los repositorios de paquetes del sistema y procedemos a instalar Nginx, utilizamos los siguientes comandos: sudo apt update y sudo apt install nginx -y.</p> <p></p> <p>Instalaci\u00f3n de Python y de su gestor de paquetes pip, este paquete proporciona las herramientas necesarias para instalar y gestionar paquetes de Python 3, utiliza el comando sudo apt install python3-pip.</p> <p></p> <p>Instalamos el paquete pipenv que permite crear y gestionar entornos virtuales para proyectos de Python, mediante el comando sudo apt install pipenv.</p> <p></p> <p>Despu\u00e9s de la instalaci\u00f3n, verificamos que pinev se ha instalado correctamente, mediante el comando pipenv --version.</p> <p></p> <p>Creamos un nuevo directorio con el comando sudo mkdir nombre-directorio, accedemos al directorio y verificamos sus permisos, con el comando ls -lh que mostrar\u00e1 la informaci\u00f3n sobre el propietario y los permisos asociados al directorio, como hemos utilizado sudo al crear la carpeta, el propietario sera root.</p> <p></p> <p>Hay que cambiar los permisos del directorio para que el due\u00f1o sea nuestro usuario y pertenezca al grupo www-data*, y establecemos los permisos adecuados a este directorio, para que pueda ser le\u00eddo por todo el mundo, comandos sudo chown -R $USER:www-data /var/www/mi_aplicacion y chmod -R 755 /var/www/mi_aplicacion**.</p> <p></p> <p>Creamos el archivo .env en el directorio del proyecto. Este archivo es importante para definir variables de entorno, como la aplicaci\u00f3n de Flask y el modo de entorno.</p> <p></p> <p>Configuramos el archivo .env con las directivas necesarias para la aplicaci\u00f3n de Flask. En este caso, configuramos la variable de entorno FLASK_APP que especifica el archivo que contiene la aplicaci\u00f3n Flask y FLASK_ENV que define el entorno de ejecuci\u00f3n, como desarrollo o producci\u00f3n.</p> <p></p> <p>Usamos el comando pipenv shell para activar el entorno virtual gestionado por pipenv, este comando nos coloca dentro de un entorno virtual donde podemos instalar y gestionar dependencias de Python.</p> <p></p> <p>Con el entorno virtual activado, instalamos Flask y Gunicorn, que es un servidor WSGI para aplicaciones web de Python. Gunicorn se utiliza en producci\u00f3n para ejecutar aplicaciones Flask de manera eficiente, utiliza el comando pipenv install flask gunicorn para descargar e instalar las dependencias necesarias dentro del entorno virtual.</p> <p></p> <p>Creamos los archivos application.py en donde se define la aplicaci\u00f3n Flask y wsgi.py archivo que Gunicorn usar\u00e1 para servir la aplicaci\u00f3n.</p> <p></p> <p>Una vez que la aplicaci\u00f3n y los archivos necesarios est\u00e1n configurados, ejecutamos el servidor de desarrollo Flask usando Gunicorn con el comando flask run --host '0.0.0.0', que lanzar\u00e1 la aplicaci\u00f3n Flask y hace que sea accesible en todas las interfaces de red de la m\u00e1quina (no solo en localhost).</p> <p></p> <p>Muestra que la aplicaci\u00f3n Flask se ejecuta correctamente en el servidor y es accesible.</p> <p></p> <p>Comprobamos ahora que Gunicorn funciona correctamente tambi\u00e9n, deb\u00e9is usar el comando gunicorn --workers 4 --bind 0.0.0.0:5000 wsgi:app para probar que la aplicaci\u00f3n funciona correctamente usando Gunicorn.</p> <p></p> <p></p> <p>Dentro de nuestro entorno virtual, debemos tomar nota de cual es el path o ruta desde la que se ejecuta gunicorn para poder configurar m\u00e1s adelante un servicio de sistema, utiliza el comando which gunicorn.</p> <p></p> <p>Salimos de nuestro entorno virtual con el comando deactivate.</p> <p></p> <p>Inicializamos Nginx y comprobamos que est\u00e9 ejecutandose correctamente, con los comandos sudo systemctl start nginx y sudo systemctl status nginx.</p> <p>Antes de ello debemos parar el servicio Apache si esta usando el puerto 80, mediante los comandos sudo systemctl disable apache2 y sudo systemctl stop apache2.</p> <p></p> <p>Creamos un archivo para que systemd corra Gunicorn como un servicio del sistema m\u00e1s.</p> <p></p> <p>Ahora habilita e inicia el servicio nuevo en systemd, mediante los comandos systemctl enable nombre_servicio y systemctl start nombre_servicio.</p> <p></p> <p>Creamos un archivo con el nombre de nuestra aplicaci\u00f3n y dentro establecemos la configuraci\u00f3n para ese sitio web.</p> <p></p> <p>Creamos el enlace simb\u00f3lico del archivo para activar el sitio web y nos aseguramos de que se haya creado correctamente, con los comandos sudo ln -s /etc/nginx/sites-available/nombre_aplicacion /etc/nginx/sites-enabled/ y ls -l /etc/nginx/sites-enabled/ | grep nombre_aplicacion.</p> <p></p> <p>Comprueba que no haya habido errores de sintaxis y reinicia el servicio.</p> <p></p> <p>Edita el archivo /etc/hosts de la m\u00e1quina anfitriona y a\u00f1ade la IP de la m\u00e1quina virtual junto a su server_name, despu\u00e9s comprueba el resultado en la m\u00e1quina anfitriona.</p> <p></p> <p></p>"},{"location":"tema-3/practica3-3/#clonacion-nuevo-repositorio-y-procedimiento-de-despliegue","title":"Clonaci\u00f3n nuevo repositorio y procedimiento de despliegue","text":"<p>Ahora vamos a clonar el repositorio git clone https://github.com/raul-profesor/Practica-3.5 dentro de nuestra carpeta /var/www/.</p> <p></p> <p>Creamos el archivo .env dentro de la carpeta clonada.</p> <p></p> <p>Cambiamos al usuario y grupo due\u00f1os del directorio y le a\u00f1adimos permisos a la carpeta, con los comandos sudo chown -R y chmod -R.</p> <p></p> <p>Crea un nuevo entorno virtual y descarga e instala las dependencias flask gunicorn, con los comandos pipenv shell y pipenv install flask gunicorn.</p> <p></p> <p>Ejecutamos el servidor de desarrollo Flask usando Gunicorn con el comando flask run --host '0.0.0.0', que lanzar\u00e1 la aplicaci\u00f3n Flask y hace que sea accesible en todas las interfaces de red de la m\u00e1quina (no solo en localhost).</p> <p></p> <p>Muestra que la aplicaci\u00f3n Flask se ejecuta correctamente en el servidor y es accesible.</p> <p></p> <p>Dentro de nuestro entorno virtual, debemos tomar nota de cual es el path o ruta desde la que se ejecuta gunicorn para poder configurar m\u00e1s adelante un servicio de sistema, utiliza el comando which gunicorn</p> <p></p> <p>Salimos de nuestro entorno virtual con el comando deactivate.</p> <p>Creamos un archivo para que systemd corra Gunicorn como un servicio del sistema m\u00e1s.</p> <p></p> <p>Creamos un nuevo archivo con el nombre de nuestra nueva aplicaci\u00f3n y dentro establecemos la configuraci\u00f3n para ese sitio web.</p> <p></p> <p>Ahora habilita e inicia el servicio nuevo en systemd, mediante los comandos systemctl enable nombre_servicio y systemctl start nombre_servicio.</p> <p></p> <p>Reiniciamos Nginx y comprobamos que est\u00e9 ejecutandose correctamente, con los comandos sudo systemctl restart nginx y sudo systemctl status nginx.</p> <p></p> <p>Creamos el nueov enlace simb\u00f3lico del archivo para activar el sitio web y nos aseguramos de que se haya creado correctamente, con los comandos sudo ln -s /etc/nginx/sites-available/nombre_aplicacion /etc/nginx/sites-enabled/ y ls -l /etc/nginx/sites-enabled/ | grep nombre_aplicacion.</p> <p></p> <p>Edita el archivo /etc/hosts de la m\u00e1quina anfitriona y a\u00f1ade la IP de la m\u00e1quina virtual junto a su server_name, despu\u00e9s comprueba el resultado en la m\u00e1quina anfitriona.</p> <p></p> <p>Mostramos que se visualiza correctamente el repositorio al acceder desde el navegador de nuestra m\u00e1quina anfitriona a www.flask_raul.</p> <p></p>"},{"location":"tema-3/practica3-3/#cuestiones","title":"Cuestiones","text":""},{"location":"tema-3/practica3-3/#cuestion-1","title":"Cuesti\u00f3n 1","text":"<p>Busca, lee, entiende y explica qu\u00e9 es y para que sirve un servidor WSGI.</p> <p>Est\u00e1ndar en Python que define c\u00f3mo un servidor web debe comunicarse con las aplicaciones web escritas en Python. Su prop\u00f3sito es permitir que las aplicaciones web basadas en Python se ejecuten de manera eficiente sobre un servidor web, actuando como un intermediario entre el servidor web y la aplicaci\u00f3n. El servidor WSGI se encarga de manejar las solicitudes del cliente, pasarlas a la aplicaci\u00f3n web, y luego enviar de vuelta la respuesta al cliente.</p>"},{"location":"tema-4/practica4-1/","title":"Pr\u00e1ctica 4.1 - Configuraci\u00f3n de un servidor DNS","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 14/01/2024</p> <p>Curso: 2\u00ba de Desarrollo de Aplicaciones Web</p>"},{"location":"tema-4/practica4-1/#practica-41-configuracion-de-un-servidor-dns","title":"Pr\u00e1ctica 4.1: Configuraci\u00f3n de un servidor DNS","text":""},{"location":"tema-4/practica4-1/#nota-importante","title":"Nota importante","text":"<p>Antes de empezar la pr\u00e1ctica, recuerda eliminar las entradas del archivo /etc/hosts para asegurar que la resoluci\u00f3n de nombres va a nuestro servidor DNS.</p> <p>En mi caso no las he eliminado, sino que las he comentado por si tengo que usarlas en el futuro, es lo mismo ya que dejan de ejecutarse en el script al comentarlas.</p> <p></p>"},{"location":"tema-4/practica4-1/#ips-del-servidor-y-cliente","title":"IPS DEL SERVIDOR Y CLIENTE","text":"<p>He usado el comando ip a para mostrar mis datos de configuraci\u00f3n de red tanto del servidor como del cliente, y que sea m\u00e1s f\u00e1cil entender los siguientes pasos.</p> <p>La IP de mi servidor DNS es 192.168.116.163</p> <p></p> <p>La IP de mi cliente es 192.168.116.169</p> <p></p> <p>Habilita el puerto 53 tanto para el servidor como para el cliente, para ello antes debes instalar el paquete ufw para gestionar los puertos, comandos sudo apt install ufw y sudo ufw allow 53.</p> <p></p> <p></p>"},{"location":"tema-4/practica4-1/#instalacion-de-servidor-dns","title":"Instalaci\u00f3n de servidor DNS","text":"<p>Vamos a utilizar el paquete Bind que es una herramienta de software libre para plataformas Unix y Linux, y que es est\u00e1ndar para servidores DNS.</p> <p>Para instalarlo introduce el comando: sudo apt-get install bind9 bind9utils bind9-doc.</p> <p></p>"},{"location":"tema-4/practica4-1/#configuracion-del-servidor","title":"Configuraci\u00f3n del servidor","text":"<p>Accedemos al archivo named.conf dentro de /etc/default y modificamos la l\u00ednea OPTIONS para indicar que solo queremos configurar y usar IPv4.</p> <p>Comando para acceder al archivo: sudo nano /etc/default/named y modificamos la l\u00ednea OPTIONS con OPTIONS = \"-u bind -4\" para que s\u00f3lo use IPv4.</p> <p></p> <p>Acceso al archivo de configuraci\u00f3n principal del servidor DNS Bind. En este archivo se define como se comporta el servidor y que otros archivos de configuraci\u00f3n se incluir\u00e1n, en este caso se incluye el archivo named.conf.options para configuraciones globales, como opciones de red y directivas generales del servidor y named.conf.local donde se definen las zonas directas e inversas para dominios personalizados. </p> <p>Comando sudo nano /etc/bind/named.conf.</p> <p></p>"},{"location":"tema-4/practica4-1/#configuracion-namedconfoptions","title":"Configuraci\u00f3n named.conf.options","text":"<p>Hacemos una copia de seguridad antes de modificar el archivo de configuraci\u00f3n named.conf, para evitar posibles problemas.</p> <p>Comando sudo cp /etc/bind/named.conf.options /etc/bind/named.conf.options.backup.</p> <p></p> <p>Editamos el archivo named.conf.options y incluimos por motivos de seguridad, una lista de acceso para que solo puedan realizar consultas recursivas al servidor aquellos hosts que decidamos, denegamos las transferencias de zona, configuramos el puerto DNS 53 con nuestra IP de red privada, y comentamos la \u00faltima l\u00ednea listen-on-v6 { any;};.</p> <pre><code>    Archivo /etc/bind/named.conf.options\n\n    acl confiables {\n        192.168.116.0/24;\n    };\n\n    options {\n        directory \"/var/cache/bind\";\n\n        // If there is a firewall between you and nameservers you want\n        // to talk to, you may need to fix the firewall to allow multiple\n        // ports to talk.  See http://www.kb.cert.org/vuls/id/800113\n\n        // If your ISP provided one or more IP addresses for stable\n        // nameservers, you probably want to use them as forwarders.\n        // Uncomment the following block, and insert the addresses replacing\n        // the all-0's placeholder.\n\n        // forwarders {\n        //      0.0.0.0;\n        // };\n        allow-query {confiables;};\n        allow-recursion {confiables;};\n        allow-transfer {none;};\n        listen-on port 53{192.168.116.163;};\n        //listen-on-v6 {none;};\n        recursion yes;\n\n        //========================================================================\n        // If BIND logs error messages about the root key being expired,\n        // you will need to update your keys.  See https://www.isc.org/bind-keys\n        //========================================================================\n        dnssec-validation no;\n\n        // listen-on-v6 { any; };\n    };\n</code></pre> <p></p> <p>Comprobamos que la configuraci\u00f3n del archivo anterior es correcta, con el comando sudo named-checkconf, si no devuelve nada esta correcto, en caso contrario devolver\u00e1 la l\u00ednea donde ocurri\u00f3 el error.</p> <p></p> <p>Reiniciamos el servicio named y comprobamos que su estado es correcto.</p> <p>Comandos: sudo systemctl restart named y sudo systemctl status named.</p> <p></p>"},{"location":"tema-4/practica4-1/#configuracion-namedconflocal","title":"Configuraci\u00f3n named.conf.local","text":"<p>Accedemos a este archivo que est\u00e1 dentro de /etc/bind/ y definimos una nueva zona, con un servidor DNS maestro y la ubicaci\u00f3n del archivo de zona directa que despu\u00e9s crearemos.</p> <p>Comando: sudo nano /etc/bind/named.conf.local.</p> <pre><code>    Archivo /etc/bind/named.conf.local\n\n    //\n    // Do any local configuration here\n    //\n\n    // Consider adding the 1918 zones here, if they are not used in your\n    // organization\n    //include \"/etc/bind/zones.rfc1918\";\n\n    zone \"manuelgom.es\" {   \n            type master;    //  Define esta zona como principal\n            file \"/ect/bind/db.manuelgom.es\"; // Ruta donde ubicamos nuestro archivo de zona\n    };\n</code></pre> <p></p>"},{"location":"tema-4/practica4-1/#creacion-del-archivo-de-zona","title":"Creaci\u00f3n del archivo de zona","text":"<p>Creamos el archivo de zona de resoluci\u00f3n directa en el directorio previamente indicado y con el mismo nombre, esta zona ser\u00e1 la encargada de traducir nombres de dominio en direcciones IP.</p> <p>Los registros SOA detallan aspectos de la zona autoritativa, los NS indican los servidores DNS de la zona, en mi caso ns1.manuelgom.es es el servidor responsable de mi zona, y los A asignan un subdominio a las IPs respectivas para resolver consultas relacionadas con ese nombre, en mi caso usar\u00e9 un subdominio distinto del servidor para el cliente, ya que es lo m\u00e1s adecuado.</p> <p>Comando: sudo nano /etc/bind/manuelgom.es.</p> <p></p> <pre><code>    Archivo /etc/bind/db.manuelgom.es\n\n    $TTL    604800\n    @       IN      SOA     ns1.manuelgom.es. admin.manuelgom.es. (\n                    2025011610 ;Serial\n                    3600       ;Refresh\n                    1800       ;Retry\n                    604800     ;Expire\n                    86400      ;Negative Cache TTL\n            )\n\n        ;Definimos el servidor de nombres\n        IN      NS      ns1.manuelgom.es.\n\n    ;Definimos la IP del servidor de nombre y del cliente\n    ns1     IN      A       192.168.116.163\n    www     IN      A       192.168.116.169\n</code></pre>"},{"location":"tema-4/practica4-1/#creacion-del-archivo-de-zona-para-la-resolucion-inversa","title":"Creaci\u00f3n del archivo de zona para la resoluci\u00f3n inversa","text":"<p>Ahora debemos de modificar el archivo named.conf.local y a\u00f1adir las l\u00edneas correspondientes a la zona inversa, que ser\u00e1 la encargada de traducir direcciones IP a nombres de dominio.</p> <p>Comando: sudo nano /etc/bind/named.conf.local.</p> <pre><code>    Archivo /etc/bind/named.conf.local\n\n    //\n    // Do any local configuration here\n    //\n\n    // Consider adding the 1918 zones here, if they are not used in your\n    // organization\n    //include \"/etc/bind/zones.rfc1918\";\n\n    zone \"manuelgom.es\" {\n            type master;\n            file \"/etc/bind/db.manuelgom.es\"; // Ruta donde ubicamos nuestro archivo de zona\n    };\n\n    zone \"116.168.192.in-addr.arpa\" {\n            type master;\n            file \"/etc/bind/db.116.168.192\"; // Ruta donde ubicamos nuestro archivo de zona inversa\n    };\n</code></pre> <p></p> <p>Creamos el archivo de configuraci\u00f3n SOA para la zona inversa, y definimos el servidor de nombres, y el valor del \u00faltimo octeto de bits en decimal, tanto del servidor como del cliente con un registro PTR, que convierte la direcci\u00f3n IP al nombre de dominio.</p> <p>Comando sudo nano /etc/bind/db.116.168.192</p> <pre><code>    Archivo /etc/bind/db.116.168.192\n\n    $TTL    604800\n    @       IN      SOA     ns1.manuelgom.es. admin.manuelgom.es. (\n                    2025011604 ;Serial\n                    3600       ;Refresh\n                    1800       ;Retry\n                    604800     ;Expire\n                    86400      ;Negative Cache TTL\n            )\n\n            ;Definimos el servidor de nombres\n            IN      NS      ns1.manuelgom.es.\n\n    ; Registros PTR\n    163     IN      PTR     ns1.manuelgom.es.\n    169     IN      PTR     www.manuelgom.es.\n</code></pre> <p></p>"},{"location":"tema-4/practica4-1/#comprobacion-de-las-configuraciones","title":"Comprobaci\u00f3n de las configuraciones","text":"<p>Comprobaci\u00f3n de la zona de resoluci\u00f3n inversa, con el comando sudo named checkzone db.116.168.192.</p> <p></p> <p>Comprobaci\u00f3n de la zona de resoluci\u00f3n directa, con el comando sudo named checkzone db.manuelgom.es db.116.168.192.</p> <p></p> <p>Reiniciamos el servicio y comprobamos que su estado sea correcto, sudo systemctl restart named y sudo systemctl status named.</p> <p></p> <p>Atenci\u00f3n. Es muy importante que el cliente est\u00e9 configurado para usar como servidor DNS el que acabamos de instalar y configurar. Ya sea Windows, ya sea Linux, deb\u00e9is cambiar vuestra configuraci\u00f3n de red para que la m\u00e1quina con la que hag\u00e1is las pruebas utilice este servidor DNS como el principal.</p> <p>A\u00f1adimos el DNS de nuestro servidor en el cliente, modificando el archivo /etc/hosts, en este archivo deja tu puerta de enlace, y a\u00f1ade tu dominio DNS y su IP respectiva, y una vez nos aseguramos que la configuraci\u00f3n es correcta, utiliza el comando sudo chattr +i /etc/hosts para hacer inmutable el archivo de configuraci\u00f3n y que no se modifique por el servicio NetworkManager cuando reiniciemos el adaptador de red o la m\u00e1quina, para reiniciar el adaptador y asegurarnos de que los cambios se apliquen usa el comando sudo systemctl restart networking.service. </p> <p></p>"},{"location":"tema-4/practica4-1/#comprobacion-de-las-resoluciones-y-las-consultas","title":"Comprobaci\u00f3n de las resoluciones y las consultas","text":"<p>Podemos comprobar desde los clientes con nslookup y dig las resoluciones directa e inversa, comprobando el acceso a nuestro servidor DNS mediante los comandos nslookup y dig.</p> <p>Resoluci\u00f3n directa con nslookup.</p> <p></p> <p>Resoluci\u00f3n inversa con nslookup.</p> <p></p> <p>Resoluci\u00f3n directa con dig -x.</p> <p></p> <p>Resoluci\u00f3n inversa con dig.</p> <p></p>"},{"location":"tema-4/practica4-1/#cuestiones-finales","title":"Cuestiones finales","text":"<p>Cuesti\u00f3n 1: \u00bfQu\u00e9 pasar\u00e1 si un cliente de una red diferentes a la tuya intenta hacer uso de tu DNS de alguna manera, le funcionar\u00e1?\u00bfPor qu\u00e9, en qu\u00e9 parte de la configuraci\u00f3n puede verse?</p> <p>No, debido a que en el archivo /etc/bind/named.conf.options le hemos indicado que los que pueden hacer uso de nuestro DNS son los dispositivos dentro de la red 192.168.116.0/24 mediante la ACL confiables.</p> <p>Cuesti\u00f3n 2: \u00bfPor qu\u00e9 tenemos que permitir las consultas recursivas en la configuraci\u00f3n?</p> <p>Para permitir que nuestro servidor DNS actu\u00e9 como intermediario y realize b\u00fasquedas en otros servidores DNS, pregunt\u00e1ndoles si conocen la IP asociada al recurso que est\u00e1 solicitando nuestro cliente, una vez que la encuentra el contenido es visible por pantalla.</p> <p>Cuesti\u00f3n 3: El servidor DNS que acab\u00e1is de montar, \u00bfes autoritativo?\u00bfPor qu\u00e9?</p> <p>S\u00ed, porque queremos especificar informaci\u00f3n sobre nuestra zona DNS, como el servidor de nombre primario, el email del administrador, y varios temporizadores sobre como funcionar\u00e1 nuestro servicio, para ello debemos definir el servidor de nombre primario (SOA).</p> <p>Cuesti\u00f3n 4: \u00bfD\u00f3nde podemos encontrar la directiva $ORIGIN y para qu\u00e9 sirve?</p> <p>Transforma los nombre que no acaben en punto (nombre de dominio base) convirti\u00e9ndolos en nombres FQDN (fully qualified domain name).</p> <p>Cuesti\u00f3n 5: \u00bfUna zona es id\u00e9ntico a un dominio?</p> <p>No, una zona es una parte del dominio que est\u00e1 gestionada por un servidor DNS.</p> <p>Cuesti\u00f3n 6: \u00bfPueden editarse los archivos de zona de un servidor esclavo/secundario?</p> <p>No, los archivos de un servidor esclavo son obtenidos de otro servidor autorizado para la zona, normalmente, de un servidor maestro maestro mediante transferencia de zona, los ficheros son de solo lectura, por lo tanto, no se pueden modificar.</p> <p>Cuesti\u00f3n 7: \u00bfPor qu\u00e9 podr\u00eda querer tener m\u00e1s de un servidor esclavo para una misma zona?</p> <ul> <li>Para reducir y repartir la carga entre varios servidores DNS.</li> <li>Tener mayor torelancia a fallos. Si uno de los servidores falla, los esclavos pueden seguir    respondiendo las consultas de los clientes.</li> <li>Ofrecer mayor rapidez, mejora el tiempo de respuesta en usuarios de otras regiones.</li> </ul> <p>Cuesti\u00f3n 8: \u00bfCu\u00e1ntos servidores ra\u00edz existen?</p> <p>Existen 13 servidores ra\u00edz identificables por letras (de la A a la M), pero cada uno de ellos tienen copias distribuidas por todo el mundo mediante Anycast para garantizar su disponibilidad y rendimiento, tanto los servidores ra\u00edz como las copias son identificables mediante la misma IP.</p> <p>Cuesti\u00f3n 9: \u00bfQu\u00e9 es una consulta iterativa de referencia?</p> <p>Es una respuesta parcial a la consulta, en la que nuestro servidor DNS indica otros servidores a los que se le puede consultar para resolver el nombre.</p> <p>Cuesti\u00f3n 10: En una resoluci\u00f3n inversa, \u00bfa qu\u00e9 nombre se mapear\u00eda la direcci\u00f3n IP 172.16.34.56?</p> <p>56.34.16.172.in-addr.arpa</p>"},{"location":"tema-5/practica5-1/","title":"Pr\u00e1ctica 5.1 - Ejercicios Git y GitHub","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 03/02/2025</p>"},{"location":"tema-5/practica5-1/#practica-51-ejercicios-git-y-github","title":"Pr\u00e1ctica 5.1: Ejercicios Git y GitHub","text":""},{"location":"tema-5/practica5-1/#repositorio-deaw","title":"Repositorio DEAW","text":"<p>1. Crear un repositorio en vuestro GitHub llamado DEAW.</p> <p>Dirigete a tu cuenta de GitHub, haz clic en el bot\u00f3n <code>New Repository</code>, luego a\u00f1ade un nombre para el repositorio, el propietario, una breve descripci\u00f3n de su contenido y elige si ser\u00e1 p\u00fablico o privado.</p> <p></p> <p>2. Clonar vuestro repositorio en local.</p> <p>Para clonar un repositorio utiliza el comando <code>git clone</code> junto al enlace del repositorio terminado en .git.</p> <pre><code>\n    Manuel@DESKTOP-3AN5HH7 MINGW64 ~/Documents/Curso24-25/DAW24-25\n    $ git clone https://github.com/manuelgom5/DEAW.git\n</code></pre> <p></p>"},{"location":"tema-5/practica5-1/#readme","title":"README","text":"<p>1. Crear (si no lo hab\u00e9is creado ya) en vuestro repositorio local un documento <code>README.md</code>.</p> <pre><code>    Nota\n\n    Escribir un peque\u00f1o texto en este README a prop\u00f3sito del repositorio y el m\u00f3dulo para el que se utilizar\u00e1.\n</code></pre> <p>Puedes utilizar el comando <code>echo -e</code> para introducir el texto del archivo a la misma vez que lo crea -&gt; <code>echo -e \"Cap\u00edtulo 1: Introducci\u00f3n a Git\\nCap\u00edtulo 2: Flujo de trabajo b\u00e1sico\\n\" &gt; README.md</code>.</p> <p></p>"},{"location":"tema-5/practica5-1/#commit-inicial","title":"Commit inicial","text":"<p>1. Realizar un commit inicial con el comentario <code>Comenzamos con los ejercicios de git</code>.</p> <p>Como el archivo README.md a\u00fan no ha sido agregado al \u00e1rea de staging, debes utilizar <code>git add</code> para incluirlo en el seguimiento antes de realizar el commit. Si el archivo ya estuviera en seguimiento por Git, podr\u00eda utilizar directamente <code>git commit -am 'Mensaje'</code>.</p> <p></p>"},{"location":"tema-5/practica5-1/#push-inicial","title":"Push inicial","text":"<p>1. Subir los cambios al repositorio remoto.</p> <p>Usa el comando <code>git push</code> para subir los cambios a la rama principal. Si es la primera vez que subes cambios a la rama, utiliza el flag <code>-u</code> para establecer una relaci\u00f3n de seguimiento entre una rama local y su correspondiente rama remota, para que posteriormente no sea necesario utilizar en la rama comandos como <code>git pull</code>.</p> <p></p>"},{"location":"tema-5/practica5-1/#ignorar-archivos","title":"Ignorar archivos","text":"<p>1.  Crear en el repositorio local un fichero llamado <code>privado.txt</code>.</p> <p>2.  Crear en el repositorio local una carpeta llamada <code>privada</code>.</p> <p>3.  Realizar los cambios oportunos para que tanto el archivo como la carpeta sean ignorados por git.</p> <p>Para crear el archivo, usa <code>touch privado.txt</code>, y para la carpeta <code>mkdir privada</code>, luego crea un archivo llamado <code>.gitignore</code> que incluya la ruta de ambos para que se vean y se puedan usar solo en local.</p> <p></p>"},{"location":"tema-5/practica5-1/#anadir-fichero1txt","title":"A\u00f1adir fichero1.txt","text":"<p>1. A\u00f1adir fichero <code>1.txt</code> al repositorio local.</p> <p>Para agregar el archivo al repositorio, primero a\u00f1ade el archivo al \u00e1rea de seguimiento con <code>git add</code>, ya que acaba de ser creado, agregale un mensaje con <code>git commit -m</code> y le haces un <code>git push</code> para enviar los cambios al repositorio remoto.</p> <p></p> <p>Comprobaci\u00f3n de que est\u00e1 subido en GitHub.</p> <p></p>"},{"location":"tema-5/practica5-1/#crear-el-tag-v01","title":"Crear el tag v0.1","text":"<p>1.  Crear un tag <code>v0.1</code>.</p> <p>Utiliza el comando git tag NombreTag.</p> <p></p>"},{"location":"tema-5/practica5-1/#subir-el-tag-v01","title":"Subir el tag v0.1","text":"<p>1.  Subir los cambios al repositorio remoto.</p> <p>Utiliza el comando <code>git push origin nombreTag</code> para agregarla a Github, aparecer\u00e1 en el repositorio bajo el nombre de tags.</p> <p></p> <p></p>"},{"location":"tema-5/practica5-1/#cuenta-de-github","title":"Cuenta de GitHub","text":"<p>1.  Poner una foto en vuestro perfil de GitHub.</p> <p>Dirigete a la secci\u00f3n de <code>Settings</code> y selecciona en editar tu foto.</p> <p></p> <p>2.  Poner el doble factor de autentificaci\u00f3n en vuestra cuenta de GitHub.</p> <p>Ve a <code>Settings</code> &gt; <code>Password and Authentication</code>, y configura un m\u00e9todo adicional para proteger tu cuenta. Esto asegurar\u00e1 que, al acceder desde tu equipo o cualquier otro dispositivo, necesitar\u00e1s un segundo factor de verificaci\u00f3n, como el acceso a tu m\u00f3vil, para confirmar tu identidad y realizar acciones sensibles en tu cuenta.</p> <p></p>"},{"location":"tema-5/practica5-1/#uso-social-de-github","title":"Uso social de GitHub","text":"<p>1.  Preguntar los nombres de usuario de GitHub de 2 de tus compa\u00f1eros de clase, b\u00fascalos y sigueles.</p> <p>En <code>Your Profile</code> puedes ver a las personas que est\u00e1s siguiendo y a quienes te siguen. Si haces clic sobre sus nombres, podr\u00e1s ver m\u00e1s detalles de sus perfiles.</p> <p></p> <p>2.  Seguir los repositorios <code>DEAW</code> del resto de tus compa\u00f1eros.</p> <p>Para seguir un repositorio, accede a \u00e9l y haz clic en el bot\u00f3n <code>Watch</code>. En mi caso, he seleccionado recibir notificaciones cada vez que haya cambios, menciones o comentarios en el repositorio de mi compa\u00f1ero.</p> <p></p> <p>3.  A\u00f1adir una estrella a los repositorios <code>DEAW</code> del resto de tus compa\u00f1eros.</p> <p>El bot\u00f3n para a\u00f1adir estrellas se encuentra junto al bot\u00f3n de seguimiento del repositorio. Los repositorios a los que des una estrella se pueden visualizar en la secci\u00f3n <code>Your profile</code>.</p> <p></p>"},{"location":"tema-5/practica5-1/#crear-una-tabla","title":"Crear una tabla","text":"<p>1.  Crear una tabla de este estilo en el fichero <code>README.md</code> con la informaci\u00f3n de varios de tus compa\u00f1eros de clase:</p> <p></p> <p>En README puedes crear una tabla utilizando la sintaxis adecuada.</p> <p></p> <p>Como puedes ver, GitHub es capaz de interpretar el formato de la tabla en el archivo README y la muestra en formato tabla.</p> <p></p>"},{"location":"tema-5/practica5-1/#colaboradores","title":"Colaboradores","text":"<p>1.  Poner a <code>github.com/arammes003</code> como colaborador del repositorio <code>DEAW</code>.</p> <p>Para hacerlo, accede a los <code>ajustes (Settings) de tu repositorio</code> &gt; <code>Collaborators</code>, y a\u00f1ade su nombre de usuario.</p> <p></p>"},{"location":"tema-5/practica5-1/#notas","title":"Notas","text":"<p>1.  Este ejercicio es continuaci\u00f3n del anterior por lo que tendre\u00eds que seguir trabajando en el repositorio <code>DEAW</code>.</p> <p>2.  Tambi\u00e9n tendre\u00eds que ir poniendo los <code>comandos</code> que hab\u00e9is tenido que utilizar durante todos los ejercicios y las <code>explicaciones y capturas de pantalla</code> que consider\u00e9is <code>necesarias</code> en el informe.</p>"},{"location":"tema-5/practica5-1/#crear-una-rama-v02","title":"Crear una rama v0.2","text":"<p>1.  Crear una rama <code>v0.2</code>.</p> <p>2.  Posiciona tu carpeta de trabajo en esta rama.</p> <p>Puedes realizar ambas acciones a la vez utilizando el comando <code>git checkout -b nombreRama</code>.</p> <p></p>"},{"location":"tema-5/practica5-1/#anadir-fichero-2txt","title":"A\u00f1adir fichero 2.txt","text":"<p>1.  A\u00f1adir un fichero <code>2.txt</code> en la rama <code>v0.2</code>.</p> <p>Tambi\u00e9n puedes crearlo con <code>echo -e</code> como te mostr\u00e9 previamente. Aunque est\u00e9s en otra rama, el proceso de <code>add</code> y <code>commit</code> sigue siendo el mismo.</p> <p></p>"},{"location":"tema-5/practica5-1/#crear-rama-remota-v02","title":"Crear rama remota v0.2","text":"<p>1.  Subir los cambios al repositorio remoto.</p> <p>Puedes subir la rama y su contenido haciendo uso del comando <code>git push origin NombreRama</code>.</p> <p></p> <p>Como puedes ver, ahora existe la rama en GitHub.</p> <p></p>"},{"location":"tema-5/practica5-1/#merge-directo","title":"Merge directo","text":"<p>1.  Posicionarse en la rama <code>main</code>.</p> <p></p> <p>2.  Hacer un merge de la rama <code>v0.2</code> en la rama <code>main</code></p> <p>De esta manera, los cambios realizados en tu rama <code>v0.2</code> se integran en la rama principal (<code>main</code>).</p> <p></p>"},{"location":"tema-5/practica5-1/#merge-con-conflicto","title":"Merge con conflicto","text":"<p>1.  En la rama <code>main</code> poner <code>Hola</code> en el fichero <code>1.txt</code> y hacer commit.</p> <p></p> <p></p> <p>2.  Posicionarse en la rama <code>v0.2</code> y poner <code>Adios</code> en el fichero <code>\"1.txt\"</code> y hacer commit.</p> <p>Sobreescribimos la misma l\u00ednea con un nuevo contenido y guardamos el archivo.</p> <p></p> <p>3.  Posicionarse de nuevo en la rama <code>main</code> y hacer un merge con la rama <code>v0.2</code>.</p> <p>Como se puede visualizar esto llevar\u00e1 a un conflicto, ya que el archivo tiene contenido distinto en ambos commits.</p> <p></p>"},{"location":"tema-5/practica5-1/#listado-de-ramas","title":"Listado de ramas","text":"<p>1.  Listar las ramas con merge y las ramas sin merge.</p> <p>Para listar las ramas que ya han sido mergeadas, utiliza <code>git branch --merged</code>. Para listar las ramas que a\u00fan no han sido mergeadas, utiliza <code>git branch --no-merged</code>.</p> <p></p>"},{"location":"tema-5/practica5-1/#arreglas-conflictos","title":"Arreglas conflictos","text":"<p>1.  Arreglar el conflicto anterior y hacer un commit.</p> <p>Resolvemos el conflicto eligiendo mantener ambas modificaciones en l\u00edneas separadas. Luego, realizamos un commit utilizando <code>git commit -am</code> para agregar el archivo sin conflictos y guardarlo.</p> <p></p>"},{"location":"tema-5/practica5-1/#borrar-rama","title":"Borrar rama","text":"<p>1.  Crear un tag <code>v0.2</code>.</p> <p>Utiliza el comando <code>git tag NombreTag</code> para crear el nuevo tag.</p> <p></p> <p>2.  Borrar la rama <code>v0.2</code>.</p> <p>Para eliminar una rama, debemos borrarla tanto localmente como de manera remota. Usa <code>git branch -d NombreRama</code> para eliminarla localmente y <code>git push origin --delete NombreRama</code> para borrarla del repositorio remoto.</p> <p></p> <p></p>"},{"location":"tema-5/practica5-1/#listado-de-cambios","title":"Listado de cambios","text":"<p>1.  Listar los distintos commits con sus ramas y sus tags.</p> <p>El comando <code>git log --oneline --decorate --graph --all</code> muestra cada commit en una sola l\u00ednea, con todas sus referencias (nombres ramas, tags, merges)</p> <p></p>"},{"location":"tema-5/practica5-1/#referencias","title":"Referencias","text":"<p>Pro Git book, written by Scott Chacon and Ben Straub and published by Apress</p>"},{"location":"tema-5/practica5-1/#practica-52-ejercicios-git-y-github","title":"Pr\u00e1ctica 5.2: Ejercicios Git y GitHub","text":"<pre><code>    Nota\n\n    Cuando se habla de **zona de intercambio temporal** o zona **staging**, estamos hablando de un add\n</code></pre> <pre><code>    Si ten\u00e9is dudas para realizar estos ejercicios, pod\u00e9is consultar la [siguiente web](https://aprendeconalf.es/docencia/git/manual/)\n</code></pre>"},{"location":"tema-5/practica5-1/#enunciados-ejercicios-de-creacion-y-actualizacion-de-repositorios","title":"Enunciados: Ejercicios de creaci\u00f3n y actualizaci\u00f3n de repositorios","text":""},{"location":"tema-5/practica5-1/#ejercicio-1","title":"Ejercicio 1","text":"<p>Configurar Git definiendo el nombre del usuario, el correo electr\u00f3nico y activar el coloreado a la salida.</p> <p>Para que Git asocie correctamente los commits a nuestra identidad, debemos configurar el nombre de usuario y el correo electr\u00f3nico con los comandos <code>git config --global user.name</code> y <code>user.email</code>, y para mejorar la legibilidad de los mensajes, podr\u00edamos activar el coloreado con <code>git config --global color.ui auto</code>.</p> <p></p> <p>Mostrar la configuraci\u00f3n final.</p> <p>Con el comando <code>git config --global --list</code> podemos comprobar que los datos se han introducido correctamente.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-2","title":"Ejercicio 2","text":"<p>Crear un repositorio nuevo con el nombre <code>libro</code> y mostrar su contenido.</p> <p>Usa <code>mkdir NombreRepo</code> para crearlo, luego accede a \u00e9l con <code>cd</code> e inicializa el repositorio con <code>git init</code>.</p> <p></p> <p>Para mostrar su contenido utiliza el comando <code>ls -la</code>.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-3","title":"Ejercicio 3","text":"<p>Comprobar el estado del repositorio.</p> <p>Uso del comando <code>git status</code>.</p> <p></p> <p>Crear un fichero <code>indice.txt</code> con el siguiente contenido:</p> <p><code>Cap\u00edtulo 1: Introducci\u00f3n a Git</code> <code>Cap\u00edtulo 2: Flujo de trabajo b\u00e1sico</code> <code>Cap\u00edtulo 3: Repositorios remotos</code></p> <p>Crea la rama main y accede a ella con <code>git branch -M main</code>, despu\u00e9s crea el fichero y su contenido con <code>echo -e</code> y muestra su contenido con <code>cat</code>.</p> <p></p> <p>Comprobar de nuevo el estado del repositorio.</p> <p></p> <p>A\u00f1adir el fichero a la zona de intercambio temporal.</p> <p></p> <p>Volver a comprobar una vez m\u00e1s el estado del repositorio.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-4","title":"Ejercicio 4","text":"<p>Realizar un commit de los \u00faltimos cambios con el mensaje <code>\"A\u00f1adido \u00edndice del libro\"</code>, y ver el estado del repositorio.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-5","title":"Ejercicio 5","text":"<p>Cambiar el fichero <code>indice.txt</code> para que contenga lo siguiente:</p> <p><code>Cap\u00edtulo 1: Introducci\u00f3n a Git</code> <code>Cap\u00edtulo 2: Flujo de trabajo b\u00e1sico</code> <code>Cap\u00edtulo 3: Gesti\u00f3n de ramas</code> <code>Cap\u00edtulo 4: Repositorio de ramas</code></p> <p>Comando <code>echo -e</code> para crear el fichero a la misma vez que agregas su contenido.</p> <p></p> <p>Mostrar los cambios con respecto a la \u00faltima versi\u00f3n guardada en el repositorio.</p> <p>Para ello utiliza el comando <code>git diff HEAD</code>, tambi\u00e9n se puede usar para ver los cambios en los archivos o otras ramas.</p> <p></p> <p>Hacer un commit de los cambios con el mensaje <code>\"A\u00f1adido cap\u00edtulo 3 sobre gesti\u00f3n de ramas\"</code>.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-6","title":"Ejercicio 6","text":"<p>Mostrar los cambios de la \u00faltima versi\u00f3n del repositorio con respecto a la anterior.</p> <p>Comando <code>git diff HEAD~1</code>.</p> <p></p> <p>Cambiar el mensaje del \u00faltimo commit por <code>\"A\u00f1adido cap\u00edtulo 3 sobre gesti\u00f3n de ramas al \u00edndice\"</code>.</p> <p></p> <p>Volver a mostrar los \u00faltimos cambios del repositorio.</p> <p>Para ello existen varios comandos, en este caso he usado el comando <code>git show HEAD</code>.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicios-de-manejo-del-historial-de-cambios","title":"Ejercicios de manejo del historial de cambios","text":""},{"location":"tema-5/practica5-1/#ejercicio-1_1","title":"Ejercicio 1","text":"<p>Mostrar el historial de cambios del repositorio.</p> <p>Comando <code>git log</code> que incluye informaci\u00f3n sobre cada commit, como el identificador, autor, fecha y mensaje de commit.</p> <p></p> <p>Crear la carpeta capitulos y crear dentro de ella el fichero capitulo1.txt con el siguiente texto.</p> <p><code>Git es un sistema de control de versiones ideado por Linus Torvalds.</code></p> <p>Comandos <code>mkdir</code> para crear la carpeta, y <code>echo</code> para crear el fichero con su contenido.</p> <p></p> <p>A\u00f1adimos los cambios a la zona de intercambio temporal.</p> <p></p> <p>Hacer un commit de los cambios con el mensaje \"A\u00f1adido cap\u00edtulo 1.\" Volver a mostrar el historial de cambios del repositorio.</p> <p></p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-2_1","title":"Ejercicio 2","text":"<p>Crear el fichero <code>capitulo2.txt</code> en la carpeta capitulos con el siguiente texto.</p> <p><code>El flujo de trabajo b\u00e1sico con Git consiste en: 1- Hacer cambios en el repositorio. 2- A\u00f1adir los cambios a la zona de intercambio temporal. 3- Hacer un commit de los cambios.</code></p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p></p> <p>Hacer un commit de los cambios con el mensaje \"A\u00f1adido cap\u00edtulo 2.\"</p> <p></p> <p>Mostrar las diferencias entre la \u00faltima versi\u00f3n y dos versiones anteriores.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-3_1","title":"Ejercicio 3","text":"<p>Crear el fichero <code>`capitulo3.txt</code> en la carpeta capitulos con el siguiente texto.</p> <p><code>Git permite la creaci\u00f3n de ramas lo que permite tener distintas verisones del mismo proyecto y trabajar de manera simultanea en ellas.</code></p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p></p> <p>Hacer un commit de los cambios con el mensaje \"A\u00f1adido cap\u00edtulo 3.\"</p> <p></p> <p>Mostrar las diferencias entre la primera y la \u00faltima versi\u00f3n del repositorio.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-4_1","title":"Ejercicio 4","text":"<p>A\u00f1adir al final del fichero <code>indice.txt</code> la siguiente l\u00ednea:</p> <p>Esto se puede realizar con el comando <code>echo</code> y la doble redirecci\u00f3n.</p> <p><code>Cap\u00edtulo 5: Conceptos avanzados</code></p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p></p> <p>Hacer un commit de los cambios con el mensaje \"A\u00f1adido cap\u00edtulo 5 al indice.\".</p> <p></p> <p>Mostrar qui\u00e9n ha hecho cambios sobre el fichero <code>indice.txt</code>.</p> <p>Con el comando <code>git annotate</code> alias de <code>git blame</code> podr\u00e1s ver qui\u00e9n modific\u00f3 cada l\u00ednea de un archivo y en qu\u00e9 commit.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicios-de-deshacer-cambios","title":"Ejercicios de deshacer cambios","text":""},{"location":"tema-5/practica5-1/#ejercicio-1_2","title":"Ejercicio 1","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero <code>indice.txt</code> y guardarlo.</p> <p>Accedemos al archivo con <code>nano NombreFichero</code> y modificamos el fichero.</p> <p></p> <p>Comprobar el estado del repositorio.</p> <p></p> <p>Deshacer los cambios realizados en el fichero <code>indice.txt</code> para volver a la versi\u00f3n anterior del fichero.</p> <p>Con el comando <code>git restore</code> puedes deshacer cambios en tu directorio de trabajo, volviendo a una versi\u00f3n anterior de los archivos, ya sea desde el \u00faltimo commit o desde un commit espec\u00edfico.</p> <p></p> <p>Volver a comprobar el estado del repositorio.</p> <p>Despu\u00e9s de restaurar el archivo a una versi\u00f3n anterior que ya hab\u00eda sido commiteada, no se detectan cambios pendientes.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-2_2","title":"Ejercicio 2","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero <code>indice.txt</code> y guardarlo.</p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p></p> <p>Comprobar de nuevo el estado del repositorio.</p> <p></p> <p>Quitar los cambios de la zona de intercambio temporal, pero mantenerlos en el directorio de trabajo.</p> <p>Lo podemos lograr gracias al comando <code>git reset</code>, que se utiliza para deshacer cambios en el repositorio, en la \u00e1rea de staging, directorio de trabajo, o incluso en commits anteriores, en este caso solo introduce el nombre del archivo que has a\u00f1adido al \u00e1rea de staging.</p> <p></p> <p>Comprobar de nuevo el estado del repositorio.</p> <p></p> <p>Deshacer los cambios realizados en el fichero <code>indice.txt</code> para volver a la versi\u00f3n anterior del fichero.</p> <p>Volvemos a como estaba el archivo <code>indice.txt</code> en el commit, usando <code>git restore</code>.</p> <p></p> <p>Volver a comprobar el estado del repositorio.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-3_2","title":"Ejercicio 3","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero <code>indice.txt</code> y guardarlo.</p> <p></p> <p>Eliminar el fichero <code>capitulos/capitulo3.txt</code>.</p> <p>Comando <code>rm</code> para eliminar ficheros.</p> <p></p> <p>A\u00f1adir un fichero nuevo <code>capitulos/capitulo4.txt</code> vac\u00edo.</p> <p>Con touch puedes crear ficheros sin su contenido.</p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p></p> <p>Comprobar de nuevo el estado del repositorio.</p> <p></p> <p>Quitar los cambios de la zona de intercambio temporal, pero mantenerlos en el directorio de trabajo.</p> <p>Posible error: mejor utiliza <code>git restore --staged NombreFichero</code>.</p> <p></p> <p>Comprobar de nuevo el estado del repositorio.</p> <p></p> <p>Deshacer los cambios realizados para volver a la versi\u00f3n del repositorio.</p> <p>Comando <code>git clean -f</code>, se usa para eliminar archivos no rastreados en el directorio de trabajo.</p> <p></p> <p>Volver a comprobar el estado del repositorio.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-4_2","title":"Ejercicio 4","text":"<p>Eliminar la \u00faltima l\u00ednea del fichero <code>indice.txt</code> y guardarlo.</p> <p></p> <p>Eliminar el fichero <code>capitulos/capitulo3.txt</code>.</p> <p>Usa <code>rm</code> para borrar el fichero.</p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje \"Borrado accidental.\"</p> <p></p> <p>Comprobar el historial del repositorio.</p> <p></p> <p>Deshacer el \u00faltimo commit pero mantener los cambios anteriores en el directorio de trabajo y la zona de intercambio temporal.</p> <p>Comando <code>git reset --soft</code> permite realizar estos cambios tanto en la rama principal como en otras subramas, manteniendo los cambios anteriores en el directorio de trabajo y zona de intercambio.</p> <p></p> <p>Comprobar el historial y el estado del repositorio.</p> <p></p> <p>Volver a hacer el commit con el mismo mensaje de antes.</p> <p></p> <p>Deshacer el \u00faltimo commit y los cambios anteriores del directorio de trabajo volviendo a la versi\u00f3n anterior del repositorio.</p> <p>Comando <code>git reset --hard</code> deshace el \u00faltimo commit, eliminando todos los cambios en el directorio de trabajo que no hayan sido guardados.</p> <p></p> <p>Comprobar de nuevo el historial y el estado del repositorio.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicios-de-gestion-de-ramas","title":"Ejercicios de gesti\u00f3n de ramas","text":""},{"location":"tema-5/practica5-1/#ejercicio-1_3","title":"Ejercicio 1","text":"<p>Crear una nueva rama bibliografia y mostrar las ramas del repositorio.</p> <p>Comando <code>git branch NombreRama</code> para crearla y <code>git branch</code> para mostrarlas.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-2_3","title":"Ejercicio 2","text":"<p>Crear el fichero <code>capitulos/capitulo4.txt</code> y a\u00f1adir el texto siguiente:</p> <p><code>En este cap\u00edtulo veremos como usar GitHub para alojar repositorios en remoto.</code></p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p></p> <p>Hacer un commit con el mensaje <code>A\u00f1adido cap\u00edtulo 4.</code></p> <p></p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p>Con el comando <code>git log --graph --all --oneline</code> puedes ver el historial de todas las ramas de forma compacta, mostrando el registro de commits en un formato de una sola l\u00ednea para cada commit.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-3_3","title":"Ejercicio 3","text":"<p>Cambiar a la rama bibliografia.</p> <p>Comando git checkout NombreRama para cambiar de rama.</p> <p></p> <p>Crear el fichero <code>bibliografia.txt</code> y a\u00f1adir la siguiente referencia:</p> <p>Creamos el fichero con <code>echo -e</code> de nuevo.</p> <p><code>Chacon, S. and Straub, B. Pro Git. Apress.</code></p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p></p> <p>Hacer un commit con el mensaje <code>A\u00f1adida primera referencia bibliogr\u00e1fica.</code></p> <p></p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-4_3","title":"Ejercicio 4","text":"<p>Fusionar la rama <code>bibliografia</code> con la rama <code>main</code>.</p> <p>Nos movemos a la rama <code>main</code> y utilizamos un <code>git merge</code> para fusionar las ramas.</p> <p></p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p></p> <p>Eliminar la rama bibliografia.</p> <p>Comando <code>`git branch -d</code> borra de forma local la rama.</p> <p></p> <p>Mostrar de nuevo la historia del repositorio incluyendo todas las ramas.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-5_1","title":"Ejercicio 5","text":"<p>Crear la rama bibliografia.</p> <p></p> <p>Cambia a la rama bibliografia.</p> <p></p> <p>Cambiar el fichero <code>bibliografia.txt</code> para que contenga las siguientes referencias:</p> <p><code>Scott Chacon and Ben Straub. Pro Git. Apress. Ryan Hodson.Ry's Git Tutorial. Smashwords (2014)</code></p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje <code>A\u00f1adida nueva referencia bibliogr\u00e1fica</code>.</p> <p></p> <p>Cambiar a la rama main.</p> <p></p> <p>Cambiar el fichero <code>bibliografia.txt</code> para que contenga las siguientes referencias:</p> <p><code>Chacon, S. and Straub, B. Pro Git Apress. Loeliger, J. and McCullough, M. Version control with Git. O\u00b4Reilly.</code></p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje <code>A\u00f1adida nueva referencia bibliogr\u00e1fica.</code></p> <p></p> <p>Fusionar la rama bibliografia con la rama main.</p> <p></p> <p>Resolver el conflicto dejando el fichero <code>bibliografia.txt</code> con las referencias:</p> <p>Se resuelve el conflicto combinando ambas l\u00edneas y borrando la primera l\u00ednea del segundo texto.</p> <p><code>Chacon, S. and Straub, B. Pro Git. Apress Loeliger, J. and McCullough, M. Version control with Git. O\u00b4Reilly Hodson, R. Ry\u00b4s Git Tutorial. Smashwords (2014)</code></p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal y hacer un commit con el mensaje <code>Resuelto conflicto de bibliograf\u00eda</code>.</p> <p></p> <p>Mostrar la historia del repositorio incluyendo todas las ramas.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicios-de-repositorios-remotos","title":"Ejercicios de repositorios remotos","text":""},{"location":"tema-5/practica5-1/#ejercicio-1_4","title":"Ejercicio 1","text":"<p>Crear un nuevo repositorio p\u00fablico en GitHub con el nombre <code>libro-git</code>.</p> <p></p> <p>A\u00f1adirlo al repositorio local del libro.</p> <p>Con el comando <code>git remote add origin url</code> puedes a\u00f1adir un repositorio remoto a tu repositorio local, permitiendo as\u00ed sincronizar los cambios entre ambos.</p> <p></p> <p>Mostrar todos los repositorios remotos configurados.</p> <p>Comando git remote -v.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-2_4","title":"Ejercicio 2","text":"<p>A\u00f1adir los cambios del repositorio local al repositorio remoto de GitHub.</p> <p></p> <p>Acceder a GitHub y comprobar que se han subido los cambios mostrando el historial de versiones.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-3_4","title":"Ejercicio 3","text":"<p>Colaborar en el repositorio remoto <code>libro-git</code> de otro usuario.</p> <p>Voy a colaborar con el repositorio <code>libro-git</code> de <code>arammes</code>.</p> <p></p> <p>Clonar su repositorio <code>libro-git</code>.</p> <p>Antes de hacerlo, asegurate de que tienes permisos de colaboraci\u00f3n para poder realizar push. Luego, agrega el repositorio remtoo a tu proyecto Git local con el comando <code>git remote add origin URL</code>.</p> <p></p> <p></p> <p>A\u00f1adir el fichero <code>autores.txt</code> que contenga el nombre de usuario y su correo electr\u00f3nico.</p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p></p> <p>Hacer un commit con el mensaje <code>A\u00f1adido autor.</code></p> <p></p> <p>Subir los cambios al repositorio remoto.</p> <p></p>"},{"location":"tema-5/practica5-1/#ejercicio-4_4","title":"Ejercicio 4","text":"<p>Hacer una bifurcaci\u00f3n del repositorio remoto <code>asalber/libro-git</code> en GitHub.</p> <p>Accede al repositorio y haz clic en el bot\u00f3n <code>Fork</code>. Esto crear\u00e1 una copia del repositorio en tu cuenta de GitHub, manteniendo todos sus datos.</p> <p></p> <p>Clonar el repositorio creado en la cuenta de GitHub del usuario.</p> <p></p> <p>Crear una nueva rama autoria y activarla.</p> <p></p> <p>A\u00f1adir el nombre de usuario y su correo al fichero <code>autores.txt</code>.</p> <p></p> <p>A\u00f1adir los cambios a la zona de intercambio temporal.</p> <p></p> <p>Hacer un commit con el mensaje <code>A\u00f1adido nuevo autor.</code></p> <p></p> <p>Subir los cambios de la rama autoria al repositorio remoto en GitHub.</p> <p></p> <p>Hacer un Pull Request de los cambios en la rama autoria.</p> <p>Accede al apartado <code>Pull Request</code>, los Pull Request se utilizan para proponer cambios en un repositorio y solicitar que sean revisados antes de ser fusionados (merge) en la rama principal o otra rama destino.</p> <p></p> <p>Compara la rama <code>main</code> con los cambios sucedidos en la rama <code>autor\u00eda</code> y haz clic en <code>Create Pull Request</code>.</p> <p></p> <p>A\u00f1ade un t\u00edtulo al <code>Pull Request</code>, opcionalmente tambi\u00e9n puedes a\u00f1adirle una descripci\u00f3n y tags, una vez a\u00f1adido espera a que se publique la solicitud de merge.</p> <p></p>"},{"location":"tema-6/practica6-1/","title":"Pr\u00e1ctica 6.1 - Dockerizaci\u00f3n del despliegue de una aplicaci\u00f3n con Node.js","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 11/02/2025</p>"},{"location":"tema-6/practica6-1/#practica-61-dockerizacion-del-despliegue-de-una-aplicacion-nodejs","title":"Pr\u00e1ctica 6.1: Dockerizaci\u00f3n del despliegue de una aplicaci\u00f3n Node.js","text":"<p>El objetivo de esta pr\u00e1ctica es aprender a dockerizar y desplegar una aplicaci\u00f3n Node.js que gestiona un libro de direcciones con PostgreSQL como base de datos.</p>"},{"location":"tema-6/practica6-1/#conexion-por-ssh","title":"Conexi\u00f3n por SSH","text":"<p>El primer paso es establecer una conexi\u00f3n SSH con nuestra m\u00e1quina virtual, las conexiones SSH se utilizan para acceder de forma segura a otra m\u00e1quina de manera remota a trav\u00e9s de una red, para ello abre una terminal y escribe <code>ssh NombreUsuario@SuIp</code>.</p> <p></p>"},{"location":"tema-6/practica6-1/#despliegue-con-docker","title":"Despliegue con Docker","text":"<p>Para comenzar con la pr\u00e1ctica, vamos a clonar un repositorio con el c\u00f3digo fuente de una aplicaci\u00f3n y el archivo Dockerfile, ejecutando el comando <code>git clone https://github.com/raul-profesor/DAW_practica_6.1_2024.git</code>.</p> <p>Este comando descargar\u00e1 todo el contenido del repositorio en nuestro equipo, permiti\u00e9ndonos modificar y construir la aplicaci\u00f3n.</p> <p></p> <p>Antes de seguir adelante, se deber\u00e1 tener instalado Docker en el sistema. Para ello, ejecuta el comando <code>sudo apt install -y docker.io</code>.</p> <p></p>"},{"location":"tema-6/practica6-1/#configuracion-dockerfile","title":"Configuraci\u00f3n dockerfile","text":"<p>Cuando se clone el repositorio, ya podremos navegar hasta su directorio con <code>cd</code> y listar su contenido con <code>ls</code>. Entre los archivos, encontraremos el Dockerfile.</p> <p>Si mostramos su contenido con <code>cat</code>, veremos que est\u00e1 incompleto y necesita modificaciones para que funcione correctamente.</p> <pre><code>____ node:18.16.0-alpine3.17\n____  mkdir -p /opt/app\n_____ /opt/app\n____ src/package.json src/package-lock.json .\n___ npm install\n____ src/ .\n_______ 3000\n___ [ \"npm\", \"start\"]\n</code></pre> <p>As\u00ed que vamos a acceder al archivo Dockerfile con <code>nano</code> y a modificarlo.</p> <p></p>"},{"location":"tema-6/practica6-1/#construccion-de-imagen","title":"Construcci\u00f3n de imagen","text":"<p>Una vez corregido el Dockerfile, procedemos a construir la imagen del Docker. Para ello, ejecutamos el comando: <code>sudo docker build -t librodirecciones .</code>.</p> <p>Este comando construir\u00e1 la imagen asign\u00e1ndole el nombre librodirecciones en el directorio actual.</p> <p></p>"},{"location":"tema-6/practica6-1/#ejecucion-del-contenedor","title":"Ejecuci\u00f3n del contenedor","text":"<p>Ya construida, podremos ejecutar la aplicaci\u00f3n dentro de un contenedor con el comando <code>docker run -p 3000:3000 -d librodirecciones</code>.</p> <p></p> <p>Este comando inicia un contenedor en segundo plano basado en la imagen librodirecciones, asignando el puerto 3000 del contenedor al puerto 3000 de nuestra m\u00e1quina.</p>"},{"location":"tema-6/practica6-1/#prueba-desde-el-navegador","title":"Prueba desde el navegador","text":"<p>Despu\u00e9s de iniciar el contenedor, intentamos acceder a la aplicaci\u00f3n mediante su direcci\u00f3n IP y puerto.</p> <p>Para ello, usa el comando <code>ipconfig</code> para visualizar tu IP, en mi caso es la 192.168.100.27.</p> <p></p> <p>Accede a tu m\u00e1quina, abre el navegador e intenta acceder a http://TU-IP:3000, si te devuelve el mensaje No se puede acceder a este sitio web, abre el puerto 3000 con el comando <code>sudo ufw allow 3000</code> y vuelve a intentarlo.</p> <p></p>"},{"location":"tema-6/practica6-1/#docker-compose","title":"Docker Compose","text":"<p>Docker Compose es una herramienta para gestionar aplicaciones multicontenedor, que sirve para iniciar y detener m\u00faltiples contenedores en secuencia, conectar contenedores utilizando una red virtual, construir o descargar im\u00e1genes de contenedores, etc\u00e9tera.</p> <p>Es posible que no lo tengas instalado, para comprobarlo introduce el comando <code>docker-compose --version</code> y si no encuentra la orden escribe <code>sudo apt install -y docker-compose</code>.</p> <p></p> <p>Docker Compose utiliza un archivo de definici\u00f3n YAML, que es un formato de serializaci\u00f3n de datos para la configuraci\u00f3n de aplicaciones.</p> <p></p> <p>Ya que el puerto 3000 est\u00e1 ocupado y lo estamos usando de nuevo en el archivo docker-compose, para el servicio adressbook asegurate de parar el contenedor anterior librodirecciones para evitar problemas, comando <code>sudo docker stop librodirecciones</code>.</p> <p>Para levantar nuestra aplicaci\u00f3n basada en contenedores tendr\u00edamos que utilizar el comando <code>docker-compose run adressbook npm run migrate</code>, el servicio adressbook es una base de datos definida en el archivo docker-compose.yml y el comando <code>npm run migrate</code> se usa para ejecutar migraciones de base de datos en una aplicaci\u00f3n Node.js.</p> <p></p> <p></p> <p>Despu\u00e9s utilizaremos docker-compose up --build -d, que construye las im\u00e1genes de los servicios definidos en el archivo docker-compose.yml y levanta los contenedores en segundo plano.</p> <p></p> <p>Comprobar el estado de los contenedores, comando docker compose ps, este comando muestra los contenedores que est\u00e1n siendo gestionados por Docker Compose y su estado actual.</p> <p></p> <p>Y por \u00faltimo usamos docker compose run addressbook npm test, que ejecuta las pruebas de la aplicaci\u00f3n dentro del contenedor adressbook. </p> <p></p> <p>Resultado del test</p> <p></p>"},{"location":"tema-6/practica6-1/#tarea","title":"Tarea","text":"<p>Probad que la aplicaci\u00f3n junto con la BBDD funciona correctamente. El funcionamiento de la API es:</p> <p>Para ello desde la terminal de nuestra m\u00e1quina f\u00edsica hacemos las siguientes peticiones:</p> <ul> <li><code>PUT /persons/</code> a\u00f1ade una persona al libro de direcciones, <code>curl -X PUT http://192.168.100.27:3000/persons -H 'Content-Type: application/json' -d '{\"id\": 2, \"firstName\": \"Alfonso\", \"lastName\": \"Mestaza\"}'</code>.</li> </ul> <p></p> <ul> <li><code>GET /persons/all</code> muestra todas las personas en el libro de direcciones, <code>curl -X GET http://192.168.100.27:3000/persons/all -H 'Content-Type: application/json'</code>.</li> </ul> <p></p> <ul> <li><code>GET /persons/1</code> muestra la persona con el id 1, <code>curl -X GET http://192.168.100.27:3000/persons/1 -H 'Content-Type: application/json'</code>.</li> </ul> <p></p> <ul> <li><code>DELETE /persons/1</code> elimina la persona con el id 1.</li> </ul> <p></p>"},{"location":"tema-6/practica6-2/","title":"Pr\u00e1ctica 6.2 - Despliegue de una aplicaci\u00f3n PHP con Nginx y MySQL usando Docker y docker-compose","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 13/02/2025</p>"},{"location":"tema-6/practica6-2/#practica-62-despliegue-de-una-aplicacion-php-con-nginx-y-mysql-usando-docker-y-docker-compose","title":"Pr\u00e1ctica 6.2: Despliegue de una aplicaci\u00f3n PHP con Nginx y MySQL usando Docker y docker-compose","text":""},{"location":"tema-6/practica6-2/#proceso-de-dockerizacion-de-nginxphpmysql","title":"Proceso de dockerizaci\u00f3n de Nginx+PHP+MySQL","text":"<p>Objetivo de la pr\u00e1ctica: Configurar una infraestructura de contenedores utilizando Docker Compose para crear un servicio web con Nginx, PHP, y una base de datos MySQL. La configuraci\u00f3n tambi\u00e9n incluye la persistencia de datos de MySQL en un contenedor dedicado para almacenar las tablas de la base de datos.</p>"},{"location":"tema-6/practica6-2/#1-estructura-de-directorios","title":"1.  Estructura de directorios","text":"<p>Al finalizar esta pr\u00e1ctica, nuestra estructura de directorios debe seguir la siguiente organizaci\u00f3n:</p> <pre><code>/usuario/home/practica6-2/\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 nginx\n\u2502   \u251c\u2500\u2500 default.conf\n\u2502   \u2514\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 php\n\u2502   \u2514\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 www\n    \u2514\u2500\u2500 html\n        \u2514\u2500\u2500 index.php\n</code></pre> <p>Para ello, comenzaremos creando la estructura de directorios y archivos necesarios. M\u00e1s adelante, editaremos su contenido.</p> <p>Ejecuta los siguientes comandos para crearlos:</p> <pre><code>mkdir -p practica6-2/www/html\ncd practica6-2\ntouch docker-compose.yml\nmkdir nginx\ncd nginx/\ntouch default.conf Dockerfile\ncd ../\nmkdir php\ncd php/\ntouch Dockerfile\ncd ../\ncd www/html/\ntouch index.php\ncd ../../\n</code></pre> <p></p> <p>Ya hemos generado la estructura de archivos y carpetas necesarias, ahora vamos a visualizar la jerarqu\u00eda de directorios con la herramienta tree, la cual antes debemos instalar con el comando <code>sudo apt install tree</code>.</p> <p></p> <p>Al ejecutar el comando <code>tree</code> dentro del directorio practica6-2, puedes verificar que tu estructura coincida con la esperada.</p> <p></p>"},{"location":"tema-6/practica6-2/#2-creacion-de-un-contenedor-nginx","title":"2.  Creaci\u00f3n de un contenedor Nginx","text":"<p>El primer paso en la configuraci\u00f3n de nuestro entorno ser\u00e1 desplegar un contenedor Nginx, que servir\u00e1 para alojar nuestra aplicaci\u00f3n PHP.</p> <p>Para ello, editamos el archivo docker-compose.yml con el comando <code>sudo nano docker-compose.yml</code>.</p> <pre><code>nginx:\n  image: nginx:latest\n  container_name: nginx-container\n  ports:\n    - 80:80\n</code></pre> <p></p> <p>Este archivo descargar\u00e1 la \u00faltima versi\u00f3n de la imagen de Nginx desde Docker Hub, crea un contenedor llamado nginx-container y expone el puerto 80, mape\u00e1ndolo al puerto 80 de nuestra m\u00e1quina anfitriona, permitiendo el acceso desde el navegador.</p> <p>Una vez guardado el archivo, ejecutamos el siguiente comando para desplegar el contenedor en segundo plano <code>sudo docker compose up -d</code>.</p> <p></p> <p>Ahora debemos verificar si el contenedor se ha iniciado correctamente, utilizando el comando <code>sudo docker ps</code>.</p> <p></p> <p>Finalmente, abrimos nuestro navegador en la m\u00e1quina anfitriona, y accedemos a <code>http://IP_SERVIDOR</code>. Si todo est\u00e1 correctamente configurado, veremos la p\u00e1gina de bienvenida de Nginx.</p> <p></p>"},{"location":"tema-6/practica6-2/#3-creacion-de-un-contenedor-php","title":"3.  Creaci\u00f3n de un contenedor PHP","text":"<p>Para ejecutar c\u00f3digo PHP dentro de nuestro contenedor, primero necesitamos editar el contenido de nuestro index.php. Para ello, utiliza el comando <code>sudo nano www/html/index.php</code> y a\u00f1ade el siguiente contenido:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;head&gt;\n  &lt;title&gt;\u00a1Hola mundo!&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;h1&gt;\u00a1Hola mundo!&lt;/h1&gt;\n  &lt;p&gt;&lt;?php echo 'Estamos corriendo PHP, version: ' . phpversion(); ?&gt;&lt;/p&gt;\n&lt;/body&gt;\n</code></pre> <p></p> <p>Este archivo servir\u00e1 como una prueba para comprobar que nuestro entorno PHP est\u00e1 funcionando correctamente.</p>"},{"location":"tema-6/practica6-2/#configuracion-de-nginx-para-ejecutar-php","title":"Configuraci\u00f3n de Nginx para ejecutar PHP","text":"<p>Ahora debemos modificar el archivo de configuraci\u00f3n de Nginx para permitir la ejecuci\u00f3n de archivos PHP. Para ello, editamos nginx/default.conf con el comando <code>sudo nano nginx/default.conf</code>.</p> <p>Dentro del archivo, agregamos la siguiente configuraci\u00f3n:</p> <pre><code>server {\n\n    listen 80 default_server;  # Escucha en el puerto 80 como servidor predeterminado\n    root /var/www/html;  # Define la ra\u00edz de los archivos que se servir\u00e1n\n    index index.html index.php;  # Define los archivos de \u00edndice que se buscar\u00e1n en un directorio\n\n    charset utf-8; # Codificaci\u00f3n\n\n    location / {\n      # Intenta servir el archivo solicitado, si no existe, redirige a index.php\n      try_files $uri $uri/ /index.php?$query_string;\n    }\n\n    # Excepciones para archivos favicon.ico y robots.txt para evitar registros innecesarios\n    location = /favicon.ico { access_log off; log_not_found off; }\n    location = /robots.txt { access_log off; log_not_found off; }\n\n    # Desactiva los logs de acceso y define el log de errores\n    access_log off;\n    error_log /var/log/nginx/error.log error;\n\n    # Desactiva el uso de sendfile (mejora compatibilidad entornos virtualizados)\n    sendfile off;\n\n    # Define el tama\u00f1o m\u00e1ximo permitido para subir archivos a 100MB\n    client_max_body_size 100m;\n\n    # Configuraci\u00f3n para procesar archivos PHP\n    location ~ .php$ {\n      fastcgi_split_path_info ^(.+.php)(/.+)$;\n      fastcgi_pass php:9000;\n      fastcgi_index index.php;\n      include fastcgi_params;\n      fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n      fastcgi_intercept_errors off;\n      fastcgi_buffer_size 16k;\n      fastcgi_buffers 4 16k;\n    }\n\n    # Restringe el acceso a archivos .ht* por seguridad\n    location ~ /.ht {\n      deny all;\n    }\n    }\n</code></pre> <p></p>"},{"location":"tema-6/practica6-2/#configuracion-del-dockerfile-para-nginx","title":"Configuraci\u00f3n del Dockerfile para Nginx","text":"<p>Accedemos al archivo Dockerfile dentro de la carpeta Nginx, para asegurarnos de que el contenedor de Nginx utilice nuestra configuraci\u00f3n personalizada. Para ello, editamos el archivo con el comando <code>sudo nano practica6-2/nginx/Dockerfile</code>.</p> <p>A\u00f1ade las siguientes instrucciones:</p> <pre><code># Usamos la imagen oficial de Nginx en su \u00faltima versi\u00f3n\nFROM nginx:latest\n# Copiamos nuestro archivo de configuraci\u00f3n personalizado \"default.conf\" en el directorio Nginx\nCOPY ./default.conf /etc/nginx/conf.d/default.conf\n</code></pre> <p></p>"},{"location":"tema-6/practica6-2/#modificacion-del-docker-composeyml","title":"Modificaci\u00f3n del docker-compose.yml","text":"<p>Accedemos a docker-compose.yml para incluir el servicio de PHP-FMP y enlazarlo con Nginx. Para ello usa el comando <code>sudo nano docker-compose.yml</code>.</p> <pre><code>services:\n  nginx:\n    build: ./nginx/ # Construye la imagen con el Dockerfile dentro de la carpeta Nginx\n    container_name: nginx-container\n    ports:\n      - 80:80 # Puerto de mapeo\n    links:\n      - php # Conectamos nginx con el contenedor PHP\n    volumes:\n      - ./www/html/:/var/www/html/  # Montamos la carpeta local www/html/ en /var/www/html dentro del contenedor\n\n  php:\n    image: php:7.0-fpm  # Usamos la imagen oficial de PHP con fastCGI Process Manager\n    container_name: php-container\n    expose:\n      - 9000  # Exponemos el puerto 9000 para comunicaci\u00f3n con Nginx\n    volumes:\n      - ./www/html/:/var/www/html/  # Montamos la carpeta www/html en var/www/html dentro del contenedor\n</code></pre> <p></p> <p>Este fichero docker-compose.yml se crear\u00e1 un nuevo contenedor PHP-FPM en el puerto 9000, enlazar\u00e1 el contenedor Nginx con el contenedor PHP, as\u00ed como crear\u00e1 un volumen y lo montar\u00e1 en el directorio /var/www/html de los contenedores.</p> <p>Con todo esto configurado, ejecutamos nuevamente <code>docker-compose</code> para desplegar ambos contenedores:</p> <p></p> <p>Verificamos que ambos contenedores est\u00e1n en ejecuci\u00f3n, utilizando el comando <code>docker ps</code>.</p> <p></p> <p>Si todo est\u00e1 funcionando correctamente, podremos acceder a <code>http://IP_SERVIDOR</code> desde nuestro anfitri\u00f3n y visualizar la salida del archivo <code>index.php</code>, confirmando que PHP se est\u00e1 ejecutando dentro del contenedor.</p>"},{"location":"tema-6/practica6-2/#4-creacion-de-un-contenedor-para-datos","title":"4.  Creaci\u00f3n de un contenedor para datos","text":"<p>Hasta ahora, hemos montado el directorio <code>www/html</code> en ambos contenedores (<code>nginx</code> y <code>php</code>). Sin embargo, esta no es la mejor pr\u00e1ctica, ya que cada contenedor mantiene su propio sistema de archivos.</p> <p>En esta secci\u00f3n, vamos a crear un contenedor de datos independiente llamado <code>app-data</code>, que se encargar\u00e1 de almacenar los archivos de nuestra aplicaci\u00f3n. Luego, este contenedor se enlazar\u00e1 con los otros servicios para compartir los datos de manera eficiente.</p> <p>Primero edita el archivo docker-compose.yml  con el comando <code>sudo nano /usuario/home/practica6-2/docker-compose.yml</code>.</p> <p>Y a\u00f1ade el servicio app-data:</p> <pre><code>nginx:\n  build: ./nginx/\n  container_name: nginx-container\n  ports:\n    - 80:80\n  links:\n    - php\n  volumes_from:\n    - app-data  # Usa los vol\u00famenes del contenedor app-data\n\nphp:\n  image: php:7.0-fpm\n  container_name: php-container\n  expose:\n    - 9000\n  volumes_from:\n    - app-data  # Usa vol\u00famenes del contenedor app-data\n\napp-data: # Contenedor para el almacenamiento de archivos de la aplicaci\u00f3n\n  image: php:7.0-fpm  # Usa la imagen PHP como almacenamiento de datos\n  container_name: app-data-container  # Asigna un nombre al contenedor de datos\n  volumes: \n    - ./www/html/:/var/www/html/\n  command: \"true\" # Evita que el contenedor ejecute servicios, solo mantiene los datos\n</code></pre> <p></p> <p>Ejecutamos la nueva configuraci\u00f3n con <code>docker-compose up -d</code>.</p> <p></p> <p>Verificamos el estado de los contenedores, para asegurarnos de que todo funciona correctamente, el comando <code>docker ps</code> no nos sirve ya que tambi\u00e9n queremos ver el contenedor de app-data y con <code>docker-ps</code> solo se ven los contenedores en ejecuci\u00f3n, si queremos mostrar toda la lista de contenedores junto a sus detalles debemos usar <code>sudo docker ps -a</code>.</p> <p></p>"},{"location":"tema-6/practica6-2/#5-creacion-de-un-contenedor-mysql","title":"5.  Creaci\u00f3n de un contenedor MySQL","text":"<p>En esta secci\u00f3n, a\u00f1adiremos un contenedor de una base de datos MySQL y lo enlazaremos con el resto de servicios.</p> <p>Primero, modificaremos la imagen PHP e instalaremos la extensi\u00f3n PHP para MySQL, de tal forma que nos permita conectarnos desde nuestra aplicaci\u00f3n PHP a nuestra BBDD MySQL.</p> <p>Accedemos a nuestro archivo Dockerfile dentro de php/ con el comando <code>sudo nano php/Dockerfile</code> e incluimos el siguiente contenido:</p> <pre><code>FROM php:7.0-fpm  # Usa la imagen oficial de PHP con FPM\nRUN docker-php-ext-install pdo_mysql  # Instala la extensi\u00f3n PDO para MySQL\n</code></pre> <p></p> <p>Debemos editar docker-compose.yml con el objetivo de que se creen el contenedor para MySQL y el contenedor de los datos de MySQL que contendr\u00e1 la base de datos y las tablas:</p> <pre><code>services:\n  nginx:\n    build: ./nginx/\n    container_name: nginx-container\n    ports:\n      - 80:80\n    links:\n      - php\n    volumes_from:\n      - app-data\n  php:\n    build: ./php/\n    container_name: php-container\n    expose:\n      - 9000\n    links:\n      - mysql # Conexi\u00f3n con el contenedor MySQL\n    volumes_from:\n      - app-data\n\n  app-data:\n    image: php:7.0-fpm\n    container_name: app-data-container\n    volumes:\n      - ./www/html/:/var/www/html/\n    command: \"true\"\n\n  mysql:  # Servicio de base de datos MySQL\n    image: mysql:5.7  # Usa la imagen oficial de MySQL 5.7\n    container_name: mysql-container\n    volumes_from:\n      - mysql-data\n    environment:  # Variables de entorno para la configuraci\u00f3n de MySQL\n      MYSQL_ROOT_PASSWORD: secret\n      MYSQL_DATABASE: mydb\n      MYSQL_USER: myuser\n      MYSQL_PASSWORD: password\n\n  mysql-data: # Contenedor para almacenar los datos de MySQL\n    image: mysql:5.7\n    container_name: mysql-data-container\n    volumes:\n      - /var/lib/mysql  # Almacena los datos de un volumen persistente\n    command: \"true\" # Evita que el contenedor ejecute MySQL, solo mantiene los datos\n</code></pre> <p></p> <p>El archivo index.php dentro de www/html/ debe quedar con el siguiente contenido para comprobar la conexi\u00f3n a la base de datos.</p> <pre><code>     &lt;!DOCTYPE html&gt;\n     &lt;head&gt;\n      &lt;title&gt;\u00a1Hola mundo!&lt;/title&gt;\n     &lt;/head&gt;\n\n     &lt;body&gt;\n      &lt;h1&gt;\u00a1Hola mundo!&lt;/h1&gt;\n      &lt;p&gt;&lt;?php echo 'Estamos corriendo PHP, version: ' . phpversion(); ?&gt;&lt;/p&gt;\n      &lt;?\n        $database =\"mydb\";\n        $user = \"myuser\";\n        $password = \"password\";\n        $host = \"mysql\"; //  Nombre del servicio en docker-compose\n\n        //  Conexi\u00f3n a la base de datos MySQL usando POO\n        $connection = new PDO(\"mysql:host={$host};dbname={$database};charset=utf8\", $user, $password);\n\n        //  Consulta para obtener las tablas en la base de datos\n        $query = $connection-&gt;query(\"SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_TYPE='BASE TABLE'\");\n        $tables = $query-&gt;fetchAll(PDO::FETCH_COLUMN);\n\n        if (empty($tables)) {\n          echo \"&lt;p&gt;No hay tablas en la base de datos \\\"{$database}\\\".&lt;/p&gt;\";\n        } else {\n          echo \"&lt;p&gt;La base de datos \\\"{$database}\\\" tiene las siguientes tablas:&lt;/p&gt;\";\n          echo \"&lt;ul&gt;\";\n            foreach ($tables as $table) {\n              echo \"&lt;li&gt;{$table}&lt;/li&gt;\";\n            }\n          echo \"&lt;/ul&gt;\";\n        }\n        ?&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p></p> <p>Guardar el archivo y reconstruir los contenedores una vez m\u00e1s con <code>docker compose up -d</code>.</p> <p></p> <p>Verificamos el estado de los contenedores con <code>docker ps -a</code>.</p> <p></p>"},{"location":"tema-6/practica6-2/#6-verificacion-de-la-conexion-a-la-base-de-datos","title":"6.  Verificaci\u00f3n de la conexi\u00f3n a la base de datos","text":"<p>INFORMACI\u00d3N IMPORTANTE: Aunque en muchas de mis capturas de pantalla se muestra que estoy utilizando PHP FPM versi\u00f3n 7.0, al final tuve que cambiar a la versi\u00f3n 8.1 debido a incompatibilidades con la base de datos. Si bien la versi\u00f3n 7.0 deber\u00eda funcionar sin problemas, en caso de que encuentres alg\u00fan error, te sugiero que pruebes con una versi\u00f3n m\u00e1s reciente, como la 8.1.</p> <p>Si accedes a HTTP://IP_SERVIDOR, la p\u00e1gina deber\u00e1 mostrar el mensaje \"No hay tablas en la base de datos <code>mydb</code>\". Esto puede causar confusi\u00f3n, ya que en realidad existen tablas en la base de datos. Sin embargo, estas no son visibles para el usuario actual, ya que est\u00e1 utilizando un usuario con permisos limitados.</p> <p></p> <p>Para poder ver todas las tablas, necesitamos usar un usuario con mejores permisos. En este caso, utilizaremos el usuario root, que tiene permisos c ompletos sobre todas las bases de datos y tablas en MySQL</p> <p>Para hacerlo, debemos editar el archivo <code>index.php</code>, <code>sudo nano www/html/index.php</code>.</p> <p>Busca las credenciales de conexi\u00f3n, $user y $password y c\u00e1mbialas para que utilicen las credenciales del usuario root.</p> <p><code>$user = \"root\"; $password = \"secret\";</code></p> <p></p> <p>Guarda el archivo y refresca la p\u00e1gina. Deber\u00edas obtener ahora una pantalla con todas las tablas de la base de datos, tal que as\u00ed:</p> <p></p>"},{"location":"tema-6/practica6-2/#7-esquema-de-la-infraestructura-completa-de-contenedores","title":"7.  Esquema de la infraestructura completa de contenedores","text":"<p>Finalmente, aqu\u00ed tienes el esquema que muestra c\u00f3mo est\u00e1n organizados los contenedores en la infraestructura:</p> <p></p> <p>Este esquema ilustra c\u00f3mo los contenedores de Nginx, PHP, MySQL y almacenamiento de datos interact\u00faan entre s\u00ed para servir la aplicaci\u00f3n web, gestionar la base de datos y almacenar los datos de manera persistente.</p>"},{"location":"tema-6/practica6-3/","title":"Pr\u00e1ctica 6.3 - Servidor web con usuarios autenticados mediante servicio de directorio (LDAP)","text":"<p>Autor: Manuel G\u00f3mez Ruiz</p> <p>Asignatura: Despliegue de Aplicaciones Web</p> <p>Fecha: 20/02/2025</p>"},{"location":"tema-6/practica6-3/#practica-63-despliegue-de-servidores-web-con-usuarios-autenticados-mediante-ldap-usando-docker-y-docker-compose","title":"Pr\u00e1ctica 6.3 - Despliegue de servidores web con usuarios autenticados mediante LDAP usando Docker y Docker-compose","text":""},{"location":"tema-6/practica6-3/#despliegue-con-docker-de-nginx-demonio-de-autenticacion-ldap-openldap","title":"Despliegue con Docker de Nginx + demonio de autenticaci\u00f3n LDAP + OpenLDAP","text":"<p>Comenzamos conect\u00e1ndonos al servidor mediante SSH y creando la siguiente estructura de archivos y directorios:</p> <p></p> <p>Dentro del archivo <code>index.html</code> ubicado en el directorio <code>app</code>, se debe agregar un texto de prueba que se mostrar\u00e1 en la p\u00e1gina web.</p> <p></p> <p>En el archivo <code>ldap-nginx.conf</code>, que se encuentra en el directorio <code>conf</code>, debemos agregar la siguiente configuraci\u00f3n:</p> <p></p> <p>Con esta configuraci\u00f3n, Nginx escucha en el puerto 8080 y utiliza la ruta <code>/auth-proxy</code> para realizar una autenticaci\u00f3n previa. Se redirige la autenticaci\u00f3n al servicio en <code>http://nginx-ldap:8888</code>. Adem\u00e1s, se configuran los encabezados para que Nginx se conecte al servidor LDAP en <code>ldap://openldap:1389</code>, estableciendo el DN base y las credenciales necesarias para las consultas LDAP.</p> <p>A continuaci\u00f3n, creamos el archivo <code>docker-compose.yml</code>, con la configuraci\u00f3n adecuada para levantar los contenedores con los servicios <code>openldap</code>, <code>nginx</code> y <code>nginx-ldap</code>.</p> <p></p> <p>Una vez configurado, ejecutamos el comando <code>docker compose up -d</code> para levantar los contenedores en segundo plano.</p> <p></p> <p>Habilitamos el puerto 8080 que va a ser utilizado por Nginx en la directiva <code>proxy_pass</code>.</p> <p></p> <p>Si accedemos desde nuestra m\u00e1quina anfitriona a la IP del servidor (<code>192.168.100.27</code> en mi caso) con el puerto <code>8080</code>, nos saltar\u00e1 la autenticaci\u00f3n.</p> <p></p> <p>Y si nos autenticamos correctamente usando las credenciales LDAP, podremos acceder a la p\u00e1gina web.</p> <p></p>"},{"location":"tema-6/practica6-3/#despliegue-con-docker-de-php-apache-con-autenticacion-ldap","title":"Despliegue con Docker de PHP + Apache con autenticaci\u00f3n LDAP","text":"<p>Crea un <code>index.php</code> con un texto simple para cuando la autenticaci\u00f3n por LDAP se haya realizado correctamente.</p> <p></p> <p>Dentro del directorio <code>Docker</code> crea un archivo <code>Dockerfile</code>, si a\u00fan no lo tienes y a\u00f1adele el siguiente contenido:</p> <p></p> <p>Este archivo construye una imagen Docker que utiliza Apache y PHP, y habilita la autenticaci\u00f3n LDAP.</p> <p>Ahora debemos crear el archivo <code>ldap-demo.conf</code>, que contendr\u00e1 la configuraci\u00f3n LDAP, estableciendo los criterios de conexi\u00f3n con el contenedor de OpenLDAP, password y URL de conexi\u00f3n.</p> <p></p> <p>Por \u00faltimo, crea el archivo <code>.htaccess</code> que se utilizar\u00e1 para configurar la autenticaci\u00f3n b\u00e1sica en Apache y proteger la aplicaci\u00f3n web.</p> <p></p> <p>Para construir la imagen Docker, utilizamos el comando <code>docker build</code>.</p> <p></p> <p>Corre el contenedor en primer plano, indicando las credenciales de nuestra cuenta LDAP mediante variables de entorno con la flag <code>-e</code>.</p> <p></p> <p>Si accedemos a <code>http://IP-SERVIDOR:3000/demo</code> e introducimos en la autenticaci\u00f3n el valor pasado en la captura anterior como <code>uid</code> y el <code>LDAP_PASSWORD</code>, veremos el contenido de nuestro <code>index.php</code>.</p> <p></p>"}]}